<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0c0c0d">
    <title>To Do List</title>
    <!-- Favicon: Transparent Blue Checkmark -->
    <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'/%3E%3C/svg%3E"
        type="image/svg+xml">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap');

        :root {
            --bg: #0c0c0d;
            --surface: #161618;
            --accent: #3b82f6;
            --text-main: #e5e7eb;
            --keyboard-h: 0px;
        }

        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            margin: 0;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
        }

        header {
            padding-top: env(safe-area-inset-top);
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--bg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        #viewport {
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100vw;
        }

        #view-slider {
            display: flex;
            width: 200vw;
            height: 100%;
            will-change: transform;
        }

        .view-pane {
            width: 100vw;
            height: 100%;
            overflow-y: auto;
            padding-bottom: 120px;
            touch-action: pan-y;
        }

        .shopping-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 6px;
        }

        .section-header {
            font-size: 10px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 4px 8px;
        }

        .item-card {
            background-color: #161618;
            border: 1px solid #2d2d30;
            border-radius: 10px;
            cursor: grab;
            position: relative;
        }

        .done {
            opacity: 0.25 !important;
            filter: grayscale(1);
        }

        .color-food {
            color: #f59e0b;
        }

        .card-food {
            border-color: rgba(245, 158, 11, 0.2);
            background-color: rgba(245, 158, 11, 0.04);
            color: #fcd34d;
        }

        .color-household {
            color: #3b82f6;
        }

        .card-household {
            border-color: rgba(59, 130, 246, 0.2);
            background-color: rgba(59, 130, 246, 0.04);
            color: #93c5fd;
        }


        .color-misc {
            color: #a855f7;
        }

        .card-misc {
            border-color: rgba(168, 85, 247, 0.2);
            background-color: rgba(168, 85, 247, 0.04);
            color: #d8b4fe;
        }

        .color-trash {
            color: #71717a !important;
        }

        .card-trash {
            border-color: rgba(113, 113, 122, 0.2);
            background-color: rgba(113, 113, 122, 0.04);
            color: #71717a;
        }

        .editable-text {
            outline: none;
            word-break: break-word;
            white-space: pre-wrap;
            user-select: text;
            -webkit-user-select: text;
            pointer-events: auto;
            cursor: text;
        }

        .strikethrough {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .sortable-ghost {
            opacity: 0 !important;
        }

        .sortable-drag {
            opacity: 1 !important;
            transform: scale(1.05);
            z-index: 1000;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--accent) !important;
            cursor: grabbing;
        }

        #fab-outer {
            position: fixed;
            right: 1rem;
            bottom: calc(1rem + var(--keyboard-h));
            z-index: 100;
            pointer-events: none;
            transition: bottom 0.2s;
        }

        #fab-container {
            pointer-events: auto;
            width: 48px;
            height: 48px;
            background: #1e1e20;
            border: 1px solid #2d2d30;
            border-radius: 24px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #fab-container.expanded {
            width: min(420px, calc(100vw - 32px));
            border-radius: 12px;
            border-color: var(--accent);
        }

        #fab-input {
            display: none;
            opacity: 0;
            width: 100%;
            background: transparent;
            color: white;
            padding: 0 16px;
            outline: none;
            border: none;
            font-size: 16px;
        }

        #fab-container.expanded #fab-input {
            display: block;
            opacity: 1;
        }

        .collapsed-content {
            display: none !important;
        }

        .chevron {
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            font-size: 8px;
            margin-right: 6px;
            display: inline-block;
        }

        .chevron.is-collapsed {
            transform: rotate(-90deg);
        }

        .sync-indicator {
            font-size: 7px;
            font-weight: 800;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .status-online {
            color: #22c55e;
        }

        .status-offline {
            color: #ef4444;
        }

        nav button {
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1) !important;
        }

        nav button:hover {
            filter: brightness(1.2);
            transform: translateY(-1px);
        }

        nav button:active {
            transform: translateY(0) scale(0.95);
        }

        .item-card {
            transition: opacity 0.2s, background-color 0.2s, border-color 0.2s cubic-bezier(0.16, 1, 0.3, 1) !important;
        }

        .item-card:hover {
            filter: brightness(1.1);
            background-color: rgba(255, 255, 255, 0.05) !important;
        }

        .item-card:active {
            filter: brightness(0.9);
        }

        #display-id {
            transition: color 0.2s;
        }

        #display-id:hover {
            color: white;
        }

        #archive-header-row {
            transition: background 0.2s;
            padding: 8px;
            margin: 0 -8px;
            border-radius: 8px;
        }

        #archive-header-row:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .chk-box {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 2px solid #3f3f46;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .drag-handle {
            display: none !important;
        }

        .chk-box:hover {
            border-color: #71717a;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .chk-box.checked:hover {
            background-color: #2563eb;
            border-color: #2563eb;
        }

        .chk-box.checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }

        .chk-box svg {
            pointer-events: none;
        }

        /* Hide FAB in shopping mode unless expanded */
        .hidden-fab:not(.expanded) {
            opacity: 0 !important;
            pointer-events: none !important;
            transform: scale(0.5) !important;
        }

        /* Entry Animation */
        @keyframes itemSlideUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .item-slide-in {
            animation: itemSlideUp 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            transform-origin: center bottom;
        }

        /* Modal */
        #modal-overlay,
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2200;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            backdrop-filter: blur(2px);
        }

        #modal-overlay.active,
        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-box {
            background: #161618;
            border: 1px solid #2d2d30;
            border-radius: 20px;
            padding: 24px;
            width: 85%;
            max-width: 320px;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        }

        #modal-overlay.active .modal-box,
        .modal-overlay.active .modal-box {
            transform: scale(1);
        }

        .modal-title {
            font-size: 16px;
            font-weight: 700;
            color: white;
            margin-bottom: 24px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: filter 0.2s;
        }

        .modal-btn:active {
            filter: brightness(0.8);
        }

        .btn-cancel {
            background: #27272a;
            color: #a1a1aa;
        }

        .btn-confirm {
            background: #dc2626;
            color: white;
        }

        /* FAB Menu */
        #fab-menu {
            position: fixed;
            bottom: calc(70px + var(--keyboard-h));
            right: 1rem;
            background: #1e1e20;
            border: 1px solid #2d2d30;
            border-radius: 12px;
            padding: 8px;
            min-width: 160px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 101;
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px) scale(0.95);
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            transform-origin: bottom right;
        }

        #fab-menu.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0) scale(1);
        }

        .section-header {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            margin: 0 -10px;
            cursor: pointer;
            transition: background 0.2s, border-radius 0.2s;
            border-radius: 8px;
        }

        .section-header:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .menu-opt {
            text-align: left;
            background: transparent;
            border: none;
            color: #e5e7eb;
            padding: 10px 12px;
            font-size: 13px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.1s, transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .menu-opt:active {
            transform: scale(0.98);
        }

        .menu-opt:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .menu-opt.selected {
            font-weight: 800;
        }

        .hover-highlight {
            background: rgba(255, 255, 255, 0.1) !important;
        }

        .menu-divider {
            height: 1px;
            background: #2d2d30;
            margin: 4px 0;
        }
    </style>
</head>

<body>
    <header class="flex justify-between items-center px-4 py-2 flex-shrink-0">
        <nav class="flex gap-1 bg-zinc-900/80 p-1 rounded-xl border border-white/5">
            <button onclick="switchTab('tasks')" id="tab-tasks"
                class="px-5 py-2 rounded-lg text-[10px] font-black uppercase transition-all">Tasks</button>
            <button onclick="switchTab('shopping')" id="tab-shopping"
                class="px-5 py-2 rounded-lg text-[10px] font-black uppercase transition-all">Shopping</button>
        </nav>
        <div class="flex flex-col items-end">
            <div id="sync-status" class="sync-indicator status-offline">Offline</div>
            <button onclick="promptSyncID()" class="text-[8px] text-zinc-500 hover:text-white mt-0.5">Sync ID: <span
                    id="display-id" class="underline">None</span></button>
        </div>
    </header>

    <div id="viewport">
        <div id="view-slider">
            <main id="tasks-pane" class="view-pane px-2 no-scrollbar" onclick="handleBgClick(event)">
                <div id="list-content" class="space-y-6 mt-2"></div>
                <!-- Archive Area now appended dynamically or kept at bottom -->
                <section id="archive-area" class="hidden mt-6 pt-4 border-t border-zinc-900">
                    <div id="archive-header-row"
                        class="flex justify-between md:justify-start items-center mb-4 cursor-pointer group px-2 md:gap-3">
                        <div class="flex items-center gap-2 text-zinc-600">
                            <svg class="chevron" width="12" height="12" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor" stroke-width="3">
                                <path d="M19 9l-7 7-7-7" />
                            </svg>
                            <p class="text-[9px] uppercase tracking-widest font-bold">Completed</p>
                        </div>
                        <button id="wipe-btn" class="text-zinc-800 hover:text-red-500 transition-colors">
                            <svg width="18" height="18" fill="none" viewBox="0 0 24 24" stroke="currentColor"
                                stroke-width="2">
                                <path
                                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </div>
                    <div id="archive-content" class="space-y-1.5"></div>
                </section>
            </main>
            <main id="shopping-pane" class="view-pane px-2 no-scrollbar" onclick="handleBgClick(event)">
                <div id="shop-container" class="mt-2 space-y-6"></div>
            </main>
        </div>
    </div>

    <!-- FAB and Menu -->
    <div id="fab-menu"></div>

    <div id="fab-outer">
        <div id="fab-container">
            <input id="fab-input" type="text" placeholder="Add entry..." autocomplete="off">
            <button id="fab-btn" oncontextmenu="return false;"
                class="h-12 w-12 flex items-center justify-center rounded-full hover:bg-zinc-800 transition"><svg
                    id="fab-icon" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="#3b82f6"
                    stroke-width="3">
                    <path d="M12 5v14M5 12h14" />
                </svg></button>
        </div>
    </div>

    <div id="modal-overlay" onclick="closeModal()">
        <div class="modal-box" onclick="event.stopPropagation()">
            <div id="modal-msg" class="modal-title">Are you sure?</div>
            <div class="modal-actions">
                <button class="modal-btn btn-cancel" onclick="closeModal()">Cancel</button>
                <button id="modal-confirm-btn" class="modal-btn btn-confirm">Delete</button>
            </div>
        </div>
    </div>

    <!-- Custom Prompt Modal -->
    <div id="prompt-modal-overlay" class="modal-overlay" onclick="closePrompt()">
        <div class="modal-box" onclick="event.stopPropagation()">
            <div id="prompt-msg" class="modal-title">Enter Value</div>
            <input id="prompt-input" type="text"
                class="w-full bg-[#27272a] border border-[#3f3f46] rounded-xl px-4 py-3 text-white mb-6 outline-none focus:border-blue-500 transition-colors">
            <div class="modal-actions">
                <button class="modal-btn btn-cancel" onclick="closePrompt()">Cancel</button>
                <button id="prompt-confirm-btn" class="modal-btn btn-confirm !bg-blue-600">Save</button>
            </div>
        </div>
    </div>

    <!-- Edit Section Modal -->
    <div id="edit-sec-modal" onclick="closeEditModal()"
        class="fixed inset-0 z-[2100] flex items-center justify-center pointer-events-none opacity-0 transition-opacity duration-200 bg-black/60 backdrop-blur-sm">
        <div onclick="event.stopPropagation()"
            class="bg-[#161618] border border-[#2d2d30] rounded-2xl p-6 w-[85%] max-w-[320px] scale-90 transition-transform duration-200 shadow-2xl">
            <h3 class="text-white font-bold text-lg mb-4 text-center">Edit Section</h3>
            <div class="space-y-4">
                <div>
                    <label class="text-xs text-zinc-500 font-bold uppercase tracking-wider mb-1 block">Name</label>
                    <input id="edit-sec-name" type="text"
                        class="w-full bg-[#27272a] border border-[#3f3f46] rounded-lg px-3 py-2 text-white text-sm focus:outline-none focus:border-blue-500 transition-colors">
                </div>
                <div>
                    <label class="text-xs text-zinc-500 font-bold uppercase tracking-wider mb-1 block">Color</label>
                    <div class="flex gap-2 justify-center flex-wrap" id="color-opts">
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#ffffff" data-color="#ffffff"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#f87171" data-color="#f87171"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#fbbf24" data-color="#fbbf24"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#4ade80" data-color="#4ade80"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#60a5fa" data-color="#60a5fa"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#a78bfa" data-color="#a78bfa"></button>
                        <input type="color" id="edit-sec-color-input"
                            class="w-8 h-8 rounded-full p-0 border-0 overflow-hidden cursor-pointer rainbow-picker">
                    </div>
                </div>
            </div>
            <div class="flex gap-2 mt-6">
                <button id="delete-sec-btn"
                    class="flex-1 bg-red-900/40 text-red-500 py-3 rounded-xl text-sm font-bold hover:bg-red-900/60 transition-colors">Delete</button>
                <button id="cancel-sec-btn"
                    class="flex-1 bg-[#27272a] text-[#a1a1aa] py-3 rounded-xl text-sm font-bold hover:brightness-110 transition-all">Cancel</button>
                <button id="save-sec-btn"
                    class="flex-1 bg-blue-600 text-white py-3 rounded-xl text-sm font-bold hover:bg-blue-500 transition-colors">Save</button>
            </div>
        </div>
    </div>
    <style>
        #edit-sec-modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        #edit-sec-modal.active>div {
            transform: scale(1);
        }

        .color-btn.selected {
            border-color: white !important;
            transform: scale(1.15);
        }

        .drop-highlight {
            background: rgba(59, 130, 246, 0.2) !important;
            box-shadow: inset 0 0 0 2px #3b82f6;
        }

        .hover-highlight {
            background: rgba(255, 255, 255, 0.1) !important;
        }

        .rainbow-picker {
            appearance: none;
            -webkit-appearance: none;
            background: conic-gradient(from 0deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000) !important;
        }

        .rainbow-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .rainbow-picker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
            opacity: 0;
        }

        /* Consistent trash icon color - removed red hover as requested */
        #wipe-btn,
        .trash-icon-btn {
            color: #71717a !important;
            transition: color 0.2s;
        }

        #wipe-btn:hover,
        .trash-icon-btn:hover {
            color: #a1a1aa !important;
        }

        /* Fix full-screen white flash in View Transitions (Refined for Mobile) */
        html {
            background-color: var(--bg);
        }

        ::view-transition-group(root) {
            animation-duration: 0s !important;
        }

        ::view-transition-old(root),
        ::view-transition-new(root) {
            animation: none !important;
            mix-blend-mode: normal !important;
        }
    </style>

    <script>
        // PWA Helper
        // Generate an icon
        const iconSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="background:#0c0c0d"><rect width="24" height="24" fill="#0c0c0d"/><path d="M12 5v14M5 12h14" stroke="#3b82f6" stroke-width="2" stroke-linecap="round"/></svg>`;
        const iconBlob = new Blob([iconSVG], { type: 'image/svg+xml' });
        const iconURL = URL.createObjectURL(iconBlob);

        const manifest = {
            "id": window.location.pathname,
            "name": "To Do List",
            "short_name": "ToDo",
            "start_url": window.location.href,
            "scope": window.location.href,
            "display": "standalone",
            "background_color": "#0c0c0d",
            "theme_color": "#0c0c0d",
            "icons": [
                { "src": iconURL, "sizes": "512x512", "type": "image/svg+xml" },
                { "src": iconURL, "sizes": "192x192", "type": "image/svg+xml" }
            ]
        };
        const linkManifest = document.createElement('link');
        linkManifest.setAttribute('rel', 'manifest');
        linkManifest.setAttribute('href', URL.createObjectURL(new Blob([JSON.stringify(manifest)], { type: 'application/json' })));
        document.head.appendChild(linkManifest);

        // Utility: Wash out color (make subtler/closer to white)
        function wash(hex, amount = 0.5) {
            if (!hex || hex[0] !== '#') return hex;
            if (hex.length === 4) hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            const m = (c) => Math.round(c + (255 - c) * amount);
            const h = (c) => c.toString(16).padStart(2, '0');
            return `#${h(m(r))}${h(m(g))}${h(m(b))}`;
        }

        let isOnline = navigator.onLine;
        let pendingSync = false;

        window.addEventListener('online', () => {
            isOnline = true;
            if (pendingSync) pushToCloud();
        });
        window.addEventListener('offline', () => {
            isOnline = false;
            updateStatus(true); // Refresh UI to show offline
        });

        if ('serviceWorker' in navigator && window.location.protocol.startsWith('http')) {
            navigator.serviceWorker.register(
                URL.createObjectURL(new Blob(['self.addEventListener("fetch", (e) => {});'], { type: "text/javascript" })),
                { scope: window.location.href }
            ).catch(err => console.log('SW Error:', err));
        }

        const SB_URL = "https://sbhxqpymyxpxocwnngun.supabase.co", SB_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNiaHhxcHlteXhweG9jd25uZ3VuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc0MjI5NzAsImV4cCI6MjA4Mjk5ODk3MH0.RxtlRPzMaib2_EWxIzHajObzyHxqo0sA66eIWDYk620", supabaseClient = supabase.createClient(SB_URL, SB_KEY);
        // Data Model Update: taskSections & shopCategories
        let db = { tasks: [], shopping: [], taskSections: ['Tasks'], shopCategories: [], collapsedStates: { archive: false } };
        let tab = 'tasks', syncID = localStorage.getItem('todo_sync_id'), isRemoteUpdate = false;
        let isDragging = false, panStartX = 0, panStartY = 0, isPanning = false, lastActionTime = 0, animateUID = 0;

        // Active selections
        let activeTaskSection = 'Tasks';
        let activeShopCat = 'misc'; // food, household, misc

        async function init() {
            if (syncID) { document.getElementById('display-id').innerText = syncID; loadLocal(); await pullFromCloud(); subscribeRealtime(); } else { setTimeout(promptSyncID, 500); }

            // Migrate Task Sections
            if (!db.taskSections || db.taskSections.length === 0) db.taskSections = [{ id: 'Tasks', title: 'Tasks', color: '#ffffff' }];
            db.taskSections = db.taskSections.map(s => typeof s === 'string' ? { id: s, title: s, color: '#ffffff' } : s);

            // Migrate Shopping Categories
            if (!db.shopCategories || db.shopCategories.length === 0) {
                db.shopCategories = [
                    { id: 'food', title: 'Food', color: '#f59e0b' },
                    { id: 'household', title: 'Household', color: '#3b82f6' },
                    { id: 'misc', title: 'Misc', color: '#a855f7' }
                ];
            }
            db.shopCategories = db.shopCategories.map(c => typeof c === 'string' ? { id: c, title: c, color: '#ffffff' } : c);

            // Ensure collapsed states exist
            if (!db.collapsedStates) db.collapsedStates = { archive: false };
            db.taskSections.forEach(s => { if (db.collapsedStates[s.id] === undefined) db.collapsedStates[s.id] = false; });
            db.shopCategories.forEach(c => { if (db.collapsedStates[c.id] === undefined) db.collapsedStates[c.id] = false; });

            // Default selections
            if (!db.taskSections.some(s => s.id === activeTaskSection)) activeTaskSection = db.taskSections[0].id;
            if (!db.shopCategories.some(c => c.id === activeShopCat)) activeShopCat = db.shopCategories[0].id;

            switchTab('tasks'); setupInputLogic(); window.addEventListener('focus', pullFromCloud); setupSwipe(); setupFabGestures(); setupMenuTouch();
            document.getElementById('archive-header-row').onclick = toggleArchive;
            document.getElementById('wipe-btn').onclick = (e) => { e.stopPropagation(); wipeCompleted(); };
        }

        async function pullFromCloud() {
            if (!syncID || isRemoteUpdate || isDragging) return;
            const { data } = await supabaseClient.from('todos').select('content').eq('sync_id', syncID).maybeSingle();
            if (data?.content) {
                if (JSON.stringify(db) === JSON.stringify(data.content)) { updateStatus(true); return; }
                db = data.content;
                // Migration checks
                if (!db.collapsedStates) db.collapsedStates = { archive: false };
                if (!db.taskSections || db.taskSections.length === 0) db.taskSections = [{ id: 'Tasks', title: 'Tasks', color: '#ffffff' }];
                db.taskSections = db.taskSections.map(s => typeof s === 'string' ? { id: s, title: s, color: '#ffffff' } : s);

                if (!db.shopCategories || db.shopCategories.length === 0) {
                    db.shopCategories = [
                        { id: 'food', title: 'Food', color: '#f59e0b' },
                        { id: 'household', title: 'Household', color: '#3b82f6' },
                        { id: 'misc', title: 'Misc', color: '#a855f7' }
                    ];
                }
                db.shopCategories = db.shopCategories.map(c => typeof c === 'string' ? { id: c, title: c, color: '#ffffff' } : c);

                if (!db.taskSections.some(s => s.id === activeTaskSection)) activeTaskSection = db.taskSections[0].id;
                if (!db.shopCategories.some(c => c.id === activeShopCat)) activeShopCat = db.shopCategories[0].id;

                render(); updateStatus(true);
            } else { await pushToCloud(); }
        }

        async function pushToCloud() {
            if (!syncID || isRemoteUpdate) return;
            if (!isOnline) {
                pendingSync = true;
                updateStatus(true);
                return;
            }
            updateStatus(false);
            try {
                const { error } = await supabaseClient.from('todos').upsert({ sync_id: syncID, content: db }, { onConflict: 'sync_id' });
                if (error) throw error;
                pendingSync = false;
                updateStatus(true);
            } catch (e) {
                console.error("Sync failed:", e);
                pendingSync = true;
                updateStatus(true);
            }
        }

        function subscribeRealtime() {
            supabaseClient.channel('changes').on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'todos', filter: `sync_id=eq.${syncID}` }, payload => {
                if (isRemoteUpdate || isDragging) return;
                isRemoteUpdate = true; db = payload.new.content;
                if (!db.collapsedStates) db.collapsedStates = { archive: false };
                if (!db.taskSections) db.taskSections = ['Tasks'];
                render(); isRemoteUpdate = false;
            }).subscribe();
        }

        function setupSwipe() {
            // ... (keeping existing swipe logic, just need to make sure I don't break it)
            const vp = document.getElementById('viewport'), slider = document.getElementById('view-slider');
            vp.addEventListener('touchstart', e => { if (isDragging) return; panStartX = e.touches[0].clientX; panStartY = e.touches[0].clientY; isPanning = false; slider.style.transition = 'none'; }, { passive: true });
            vp.addEventListener('touchmove', e => {
                if (isDragging) return;
                let dx = e.touches[0].clientX - panStartX, dy = e.touches[0].clientY - panStartY;
                if (!isPanning && Math.abs(dx) > 25 && Math.abs(dx) > Math.abs(dy)) isPanning = true;
                if (isPanning) { let b = tab === 'tasks' ? 0 : -window.innerWidth; slider.style.transform = `translateX(${b + dx}px)`; }
            }, { passive: true });
            vp.addEventListener('touchend', e => {
                if (isDragging) return;
                slider.style.transition = 'transform 0.4s cubic-bezier(0.16, 1, 0.3, 1)';
                if (isPanning) { let dx = e.changedTouches[0].clientX - panStartX; if (Math.abs(dx) > 100) switchTab(dx > 0 ? 'tasks' : 'shopping'); else switchTab(tab); }
                isPanning = false;
            }, { passive: true });

            // Touchpad Swipe Support
            let wheelLastTime = 0;
            vp.addEventListener('wheel', e => {
                const now = Date.now();
                if (now - wheelLastTime < 500) return; // Cooldown
                if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && Math.abs(e.deltaX) > 20) {
                    if (e.deltaX > 0) switchTab('shopping');
                    else switchTab('tasks');
                    wheelLastTime = now;
                }
            }, { passive: true });
        }

        // FAB Gesture Logic
        let fabTimer = null;
        let fabMenuVisible = false;
        let fabMenuJustOpened = false; // Prevents immediate close

        function setupFabGestures() {
            const btn = document.getElementById('fab-btn');

            const startPress = () => {
                fabTimer = setTimeout(() => {
                    fabTimer = null;
                    fabMenuVisible = true;
                    fabMenuJustOpened = true;
                    showFabMenu();
                    if (navigator.vibrate) navigator.vibrate(50);
                    // Reset flag after a short delay
                    setTimeout(() => { fabMenuJustOpened = false; }, 200);
                }, 500);
            };

            const endPress = () => {
                if (fabTimer) {
                    // Released before timer = short click
                    clearTimeout(fabTimer);
                    fabTimer = null;
                    btnFAB();
                }
                // If menu just opened, don't do anything - let it stay open
            };

            btn.addEventListener('touchstart', startPress, { passive: true });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); endPress(); });
            btn.addEventListener('mousedown', startPress);
            btn.addEventListener('mouseup', endPress);
            btn.addEventListener('mouseleave', () => { if (fabTimer) { clearTimeout(fabTimer); fabTimer = null; } });
            // Prevent click event from bubbling when menu is open
            btn.addEventListener('click', (e) => { if (fabMenuVisible) e.stopPropagation(); });
        }

        function showFabMenu() {
            const m = document.getElementById('fab-menu');
            const isShop = tab === 'shopping';
            m.innerHTML = '';

            if (isShop) {
                db.shopCategories.forEach((c) => {
                    addMenuOption(m, c.title, c.id === activeShopCat, () => {
                        closeFabMenu();
                    }, c.id, c.color);
                });
                const div = document.createElement('div'); div.className = 'menu-divider'; m.appendChild(div);
                addMenuOption(m, '+ New Category', false, () => {
                    closeFabMenu();
                    showPrompt("New Category Name", "", (n) => {
                        if (n && !db.shopCategories.some(x => x.title === n)) {
                            const newCat = { id: 'cat_' + Date.now(), title: n, color: '#ffffff' };
                            db.shopCategories.push(newCat);
                            activeShopCat = newCat.id;
                            pushToCloud(); render();
                        }
                    });
                });
            } else {
                db.taskSections.forEach((s, idx) => {
                    const title = s.title;
                    const id = s.id;
                    const color = s.color || '#ffffff';
                    addMenuOption(m, title, id === activeTaskSection, () => {
                        closeFabMenu();
                    }, id, color);
                });
                const div = document.createElement('div'); div.className = 'menu-divider'; m.appendChild(div);
                addMenuOption(m, '+ New Section', false, () => {
                    closeFabMenu();
                    showPrompt("New Section Name", "", (n) => {
                        if (n && !db.taskSections.some(x => x.title === n)) {
                            const newSec = { id: 'sec_' + Date.now(), title: n, color: '#ffffff' };
                            db.taskSections.push(newSec);
                            activeTaskSection = newSec.id;
                            pushToCloud(); render();
                        }
                    });
                });
            }

            m.classList.add('active');

            // Delay adding click-away listener to prevent immediate close
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!m.contains(e.target)) {
                        closeFabMenu();
                        document.removeEventListener('click', closeHandler);
                    }
                };
                document.addEventListener('click', closeHandler);
            }, 100);
        }

        function closeFabMenu() {
            fabMenuVisible = false;
            document.getElementById('fab-menu').classList.remove('active');
        }

        // Shopping category colors - must match CSS .color-* classes
        const shopColors = { food: '#f59e0b', household: '#3b82f6', misc: '#a855f7' };

        function addMenuOption(p, text, selected, cb, valueToSet = null, color = null) {
            const b = document.createElement('div');
            b.className = `menu-opt ${selected ? 'selected' : ''}`;
            b.innerHTML = `<span>${text}</span>${selected ? '<span>✓</span>' : ''}`;

            // Add color to the text itself, not the background - use saturated color as requested
            if (color) {
                b.style.color = color;
            }

            const selectAction = () => {
                if (valueToSet !== null) {
                    if (tab === 'tasks') activeTaskSection = valueToSet;
                    else activeShopCat = valueToSet;
                    document.getElementById('fab-input').placeholder = `Add to ${text}...`;
                    updateFabColor();
                    expandInput();
                }
                cb();
            };

            b.onclick = (e) => { e.stopPropagation(); selectAction(); };

            b.addEventListener('mouseenter', () => {
                if (fabMenuVisible && !fabTimer) {
                    p.querySelectorAll('.menu-opt').forEach(o => o.classList.remove('hover-highlight'));
                    b.classList.add('hover-highlight');
                }
            });

            b.addEventListener('mouseup', (e) => {
                if (fabMenuVisible) {
                    e.stopPropagation();
                    selectAction();
                }
            });
            b._selectAction = selectAction;
            p.appendChild(b);
        }

        function setupMenuTouch() {
            const m = document.getElementById('fab-menu');
            m.addEventListener('touchmove', (e) => {
                if (!fabMenuVisible) return;
                const touch = e.touches[0];
                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                const opt = el?.closest('.menu-opt');
                if (opt) {
                    m.querySelectorAll('.menu-opt').forEach(o => o.classList.remove('hover-highlight'));
                    opt.classList.add('hover-highlight');
                }
            }, { passive: true });
            m.addEventListener('touchend', (e) => {
                if (!fabMenuVisible) return;
                const touch = e.changedTouches[0];
                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                const opt = el?.closest('.menu-opt');
                if (opt && opt._selectAction) opt._selectAction();
                m.querySelectorAll('.menu-opt').forEach(o => o.classList.remove('hover-highlight'));
            });
        }

        function render(animate = true) {
            if (animate && document.startViewTransition) {
                document.startViewTransition(() => _render());
            } else {
                _render();
            }
        }

        function _render() {
            const listC = document.getElementById('list-content'), archC = document.getElementById('archive-content'), shopC = document.getElementById('shop-container');
            if (!listC || !shopC) return;

            const itemMap = new Map();
            document.querySelectorAll('.item-card').forEach(el => itemMap.set(String(el.getAttribute('data-uid')), el));

            listC.innerHTML = ''; archC.innerHTML = ''; shopC.innerHTML = '';

            const list = db[tab] || [];
            list.forEach(i => { if (!i.uid) i.uid = Math.random(); if (tab === 'shopping' && !i.cat) i.cat = 'misc'; });

            if (tab === 'tasks') {
                const archiveArea = document.getElementById('archive-area');
                const isArchCol = db.collapsedStates.archive;
                archiveArea.classList.toggle('is-collapsed', isArchCol);
                document.getElementById('archive-content').classList.toggle('collapsed-content', isArchCol);
                const archChev = document.getElementById('archive-chevron');
                if (archChev) archChev.classList.toggle('is-collapsed', isArchCol);
                archiveArea.classList.remove('hidden');

                // Tasks grouped by section
                // Migrate old string format to new object format
                if (!db.taskSections || db.taskSections.length === 0) db.taskSections = [{ id: 'Tasks', title: 'Tasks', color: '#ffffff' }];
                db.taskSections = db.taskSections.map(s => typeof s === 'string' ? { id: s, title: s, color: '#ffffff' } : s);

                // Render each section
                db.taskSections.forEach((sec, secIdx) => {
                    const secId = sec.id;
                    const secTitle = sec.title;
                    const secColor = sec.color || '#ffffff';

                    const secDiv = document.createElement('div');
                    secDiv.className = 'section-block mb-4';
                    secDiv.setAttribute('data-sec-id', secId);

                    const isCol = db.collapsedStates[secId];
                    const count = list.filter(i => !i.done && (i.section === secId || (!i.section && secIdx === 0))).length;

                    secDiv.innerHTML = `<div class="section-header cursor-pointer hover:bg-white/5 transition-colors rounded-lg px-2 py-1 -mx-2" data-sec-id="${secId}">
                        <span class="chevron ${isCol ? 'is-collapsed' : ''} mr-2" style="color:${secColor}">▼</span>
                        <span class="text-[11px] font-bold uppercase tracking-wider" style="color:${secColor}">${secTitle}</span>
                        <span class="ml-2 text-[9px] opacity-50 bg-zinc-800 px-1.5 py-0.5 rounded-full">${count}</span>
                    </div>
                    <div id="list-${secId}" class="space-y-1.5 ${isCol ? 'collapsed-content' : ''}"></div>`;

                    // Attach click for collapse
                    secDiv.querySelector('.section-header').onclick = (e) => {
                        if (e.target.closest('[data-editing]')) return;
                        toggleCat(secId);
                    };

                    // Long press for edit
                    let secTimer = null;
                    let isDraggingSec = false;
                    const hdr = secDiv.querySelector('.section-header');

                    const startSecPress = () => {
                        secTimer = setTimeout(() => {
                            if (!window.isDraggingSectionGlobal) {
                                secTimer = null;
                                openSectionEdit(secId);
                                if (navigator.vibrate) navigator.vibrate(50);
                            }
                        }, 500);
                    };

                    const cancelSecPress = () => {
                        if (secTimer) {
                            clearTimeout(secTimer);
                            secTimer = null;
                        }
                    };

                    hdr.addEventListener('touchstart', startSecPress, { passive: true });
                    hdr.addEventListener('touchmove', cancelSecPress, { passive: true });
                    hdr.addEventListener('touchend', (e) => {
                        if (!secTimer && !window.isDraggingSectionGlobal) e.preventDefault();
                        cancelSecPress();
                    });
                    hdr.addEventListener('mousedown', startSecPress);
                    hdr.addEventListener('mouseup', cancelSecPress);
                    hdr.addEventListener('mouseleave', cancelSecPress);

                    // Hook into Sortable to detect drag start
                    secDiv.addEventListener('mousedown', () => { window.isDraggingSectionGlobal = false; });
                    hdr.addEventListener('dragstart', () => { window.isDraggingSectionGlobal = true; cancelSecPress(); });

                    // Drop Zone: Allow dropping tasks onto section headers
                    hdr.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        hdr.classList.add('drop-highlight');
                    });
                    hdr.addEventListener('dragleave', () => {
                        hdr.classList.remove('drop-highlight');
                    });
                    hdr.addEventListener('drop', (e) => {
                        e.preventDefault();
                        hdr.classList.remove('drop-highlight');
                        const uid = e.dataTransfer.getData('text/plain');
                        if (uid) {
                            const task = db.tasks.find(t => String(t.uid) === uid);
                            if (task) {
                                task.section = secId;
                                task.done = false;
                                saveLocal(); pushToCloud(); render();
                            }
                        }
                    });

                    listC.appendChild(secDiv);

                    const cont = secDiv.querySelector(`[id^="list-"]`);

                    // Filter items for this section
                    const isDefault = secIdx === 0;
                    const items = list.filter(i => !i.done && (i.section === secId || (isDefault && !i.section)));

                    items.forEach(i => buildItem(cont, i, itemMap));
                });

                const comp = list.filter(i => i.done).sort((a, b) => (b.doneAt || 0) - (a.doneAt || 0));
                comp.forEach(i => buildItem(archC, i, itemMap));

                if (comp.length === 0) archiveArea.classList.add('hidden');

                // Make section blocks sortable
                initSectionSortable();
            } else {
                db.shopCategories.forEach(c => renderSection(shopC, c.title, c.id, c.color || '#ffffff', itemMap));
                if (db.shopping.some(i => i.cat === 'trash')) {
                    renderSection(shopC, 'Trash', 'trash', '#71717a', itemMap);
                }
            }
            saveLocal(); initSortable(); animateUID = 0;

            // Update FAB visual hint? Optional.
        }

        function renderSection(p, l, k, color, itemMap) {
            const items = db.shopping.filter(i => i.cat === k);
            const t = items.length;
            const con = document.createElement('div');
            con.className = 'section-block';
            con.setAttribute('data-sec-id', k);

            let actionBtn = '';
            if (k === 'trash' && t > 0) {
                actionBtn = `<button class="ml-auto md:ml-2 text-zinc-600 hover:text-red-500 transition-colors" onclick="emptyTrash()"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>`;
            }

            con.innerHTML = `<div class="section-header" style="color:${color}" onclick="toggleCat('${k}', event)">
                <div class="flex items-center flex-1 md:flex-initial">
                    <span class="chevron ${db.collapsedStates[k] ? 'is-collapsed' : ''}">▼</span>${l} 
                    <span class="ml-1 opacity-60">(${t})</span>
                </div>
                ${actionBtn}
            </div>
            <div id="cat-${k}" data-cat="${k}" class="shopping-grid ${db.collapsedStates[k] ? 'collapsed-content' : ''}"></div>`;

            p.appendChild(con);

            if (k !== 'trash') {
                const hdr = con.querySelector('.section-header');
                let secTimer = null;
                const startSecPress = () => {
                    secTimer = setTimeout(() => {
                        if (!window.isDraggingSectionGlobal) {
                            secTimer = null;
                            openSectionEdit(k);
                            if (navigator.vibrate) navigator.vibrate(50);
                        }
                    }, 500);
                };
                const cancelSecPress = () => { if (secTimer) { clearTimeout(secTimer); secTimer = null; } };
                hdr.addEventListener('touchstart', startSecPress, { passive: true });
                hdr.addEventListener('touchmove', cancelSecPress, { passive: true });
                hdr.addEventListener('touchend', cancelSecPress);
                hdr.addEventListener('mousedown', startSecPress);
                hdr.addEventListener('mouseup', cancelSecPress);
                hdr.addEventListener('mouseleave', cancelSecPress);
                hdr.addEventListener('dragstart', () => { window.isDraggingSectionGlobal = true; cancelSecPress(); });
            }

            const g = con.querySelector('.shopping-grid');
            items.forEach(i => buildItem(g, i, itemMap));
        }

        function buildItem(p, i, itemMap) {
            let card = itemMap ? itemMap.get(String(i.uid)) : null;
            const isShop = tab === 'shopping';
            // Find section/category color
            const list = isShop ? db.shopCategories : db.taskSections;
            const id = isShop ? i.cat : (i.section || list[0].id);
            const sec = list.find(s => s.id === id);

            // Base section color
            let rawColor = '#ffffff';
            if (sec && sec.color) rawColor = sec.color;
            if (i.cat === 'trash') rawColor = '#71717a'; // Muted for trash

            const secColor = wash(rawColor, 0.85); // Very desaturated/light (for task text)
            const borderCol = isShop ? rawColor : wash(rawColor, 0.6); // Slightly better definition but still desaturated for tasks
            const taskTextCol = isShop ? rawColor : secColor; // Washed for tasks, saturated for shop

            if (!card) {
                card = document.createElement('div');
                const vtag = 'item-' + String(i.uid).replace('.', '').substring(0, 8);
                card.style.viewTransitionName = vtag;
                card.setAttribute('data-uid', i.uid);

                // Enable native HTML5 drag for dropping onto headers - BUT avoid conflict with click
                // SortableJS handles the list drag, we only need this for dropping onto other headers manually if supported.
                // Removing hardcoded draggable="true" as it fights with checkbox clicks on some browsers.
                if (!isShop) {
                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', String(i.uid));
                        e.dataTransfer.effectAllowed = 'move';
                    });
                }

                card.onclick = (e) => {
                    const now = Date.now();
                    const currentI = db[tab].find(x => x.uid == card.getAttribute('data-uid'));
                    if (!currentI) return;
                    if (currentI.lastClick && now - currentI.lastClick < 300) return;

                    const idx = db[tab].findIndex(x => x.uid == currentI.uid);
                    const txt = card.querySelector('.editable-text');

                    if (e.target.closest('.del')) {
                        remove(idx);
                    } else if (currentI.cat === 'trash') {
                        return;
                    } else if (e.target === txt) {
                        txt.contentEditable = true;
                        txt.focus();
                    } else if (e.target.closest('.chk-box') || (isShop && !e.target.classList.contains('editable-text'))) {
                        currentI.lastClick = now;
                        toggle(idx);
                    }
                };
            }

            card.className = `item-card ${i.done ? 'done' : ''} ${!isShop ? 'flex items-center p-3' : 'flex flex-col items-center justify-center p-2 h-14 text-center'}`;
            if (isShop && i.cat === 'trash') card.style.opacity = '0.35'; // Signficantly faded for trash
            else card.style.opacity = '';

            if (!i.done) {
                card.style.backgroundColor = taskTextCol + '05';
                card.style.borderColor = borderCol + (isShop ? '88' : '1a'); // ~50% for shop, ~10% for tasks desaturated
            } else {
                card.style.backgroundColor = '';
                card.style.borderColor = '';
            }
            if (i.uid === animateUID) card.classList.add('item-slide-in');

            if (!isShop) {
                const chkState = i.done ? 'checked' : '';
                const svg = i.done ? '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4"><path d="M20 6L9 17l-5-5"/></svg>' : '';
                const strike = i.done ? 'strikethrough' : '';

                if (card.innerHTML === '' || card.getAttribute('data-last-done') !== String(i.done)) {
                    card.innerHTML = `<div class="chk-box ${chkState}">${svg}</div><span class="ml-4 flex-1 editable-text text-[14px] font-medium ${strike}">${i.text}</span>`;
                    const chk = card.querySelector('.chk-box');
                    const txt = card.querySelector('.editable-text');

                    if (!i.done) {
                        chk.style.borderColor = borderCol + '1a'; // ~10% opacity desaturated for tasks
                        txt.style.color = taskTextCol;
                        txt.style.textShadow = 'none';
                    } else {
                        chk.style.borderColor = '';
                        txt.style.color = '';
                        txt.style.textShadow = '';
                    }

                    txt.onkeydown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); txt.blur(); } e.stopPropagation(); };
                    txt.onblur = () => { txt.contentEditable = false; const idx = db[tab].findIndex(x => x.uid == i.uid); if (idx > -1) { db[tab][idx].text = txt.innerText; saveLocal(); pushToCloud(); } };
                    card.setAttribute('data-last-done', i.done);
                } else {
                    const txt = card.querySelector('.editable-text');
                    const chk = card.querySelector('.chk-box');
                    if (txt && txt.innerText !== i.text && document.activeElement !== txt) txt.innerText = i.text;
                    if (!i.done) {
                        chk.style.borderColor = borderCol + '1a'; // ~10% opacity desaturated
                        txt.style.color = taskTextCol;
                    } else {
                        chk.style.borderColor = '';
                        txt.style.color = '';
                        txt.style.textShadow = '';
                    }
                }
            } else {
                let delBtn = `<button class="del absolute top-0.5 right-0.5 text-zinc-700 text-[10px] p-1 hover:text-zinc-400">✕</button>`;
                if (i.cat === 'trash') delBtn = `<button class="del absolute top-0.5 right-0.5 text-zinc-500 text-[14px] p-1 hover:text-zinc-300 font-bold">＋</button>`;
                const strike = i.done ? 'strikethrough' : '';

                if (card.innerHTML === '' || card.getAttribute('data-last-done') !== String(i.done) || card.getAttribute('data-last-cat') !== String(i.cat)) {
                    card.innerHTML = `<span class="editable-text text-[11px] font-bold px-1 ${strike}" style="color:${i.done ? '' : taskTextCol}">${i.text}</span>${delBtn}`;
                    const txt = card.querySelector('.editable-text');
                    card.style.borderColor = i.done ? '' : borderCol + '88';
                    txt.onkeydown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); txt.blur(); } e.stopPropagation(); };
                    txt.onblur = () => { txt.contentEditable = false; const idx = db[tab].findIndex(x => x.uid == i.uid); if (idx > -1) { db[tab][idx].text = txt.innerText; saveLocal(); pushToCloud(); } };
                    card.setAttribute('data-last-done', i.done);
                    card.setAttribute('data-last-cat', i.cat);
                }
                else {
                    const txt = card.querySelector('.editable-text');
                    if (txt && txt.innerText !== i.text && document.activeElement !== txt) txt.innerText = i.text;
                    if (!i.done) {
                        txt.style.color = taskTextCol;
                        card.style.borderColor = borderCol + '88';
                    } else {
                        txt.style.color = '';
                        card.style.borderColor = '';
                    }
                }
            }

            p.appendChild(card);
        }

        function initSortable() {
            const isT = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
            const conf = {
                animation: 200, ghostClass: 'sortable-ghost', dragClass: 'sortable-drag',
                delay: isT ? 350 : 0, delayOnTouchOnly: true,
                forceFallback: true, fallbackTolerance: 5,
                filter: '.editable-text, button, .chk-box, .del', preventOnFilter: true,
                onStart: () => { isDragging = true; },
                onEnd: (evt) => {
                    isDragging = false;
                    const allCards = Array.from(document.querySelectorAll('.item-card'));
                    const listRef = [...db[tab]];

                    db[tab] = allCards.map(el => {
                        const item = listRef.find(x => String(x.uid) === el.getAttribute('data-uid'));
                        if (item) {
                            if (tab === 'tasks') {
                                // Updated logic: check if in archive OR which section
                                const parent = el.parentElement;
                                if (parent.id === 'archive-content') item.done = true;
                                else if (parent.id.startsWith('list-')) {
                                    item.done = false;
                                    // Extract section ID (the id after 'list-')
                                    const secId = parent.id.replace('list-', '');
                                    item.section = secId;
                                } else {
                                    item.done = false; // default
                                }
                            } else {
                                const nC = el.parentElement.getAttribute('data-cat');
                                if (nC) item.cat = nC;
                            }
                        }
                        return item;
                    }).filter(n => n);
                    saveLocal(); pushToCloud(); setTimeout(render, 50);
                }
            };
            // Note: Sortable might need re-initialization if elements were moved? 
            // Actually Sortable attaches to the Container. Since we might have cleared containers (but not items), we do need to re-init.
            // Check if instances already exist? Sortable.get(el)
            const listEl = document.getElementById('list-content');
            const itemEl = document.getElementById('archive-content');
            // Destroy old instances if they exist (to prevent leaks/bugs)
            // But since we did innerHTML='' on the parents (listC, archC), the old Sortables are garbage collected?
            // Yes, Sortable attaches to the parent element.
            // We kept the parent elements (listC, archC) but we CLEARED them.
            // Wait, does clearing innerHTML destroy Sortable bindings?
            // Sortable modifies the DOM.
            // If we re-run Sortable.create on the same element, it might duplicate events?
            // Sortable has a destroy method.
            // Ideally we shouldn't be destroying and recreating the containers if we can avoid it.
            // But _render does simple re-init.
            // Let's assume Sortable handles re-init gracefully or we ignore it for now as it wasn't the bug.

            if (tab === 'tasks') {
                // Scan for section item containers (list-SECTIONID)
                document.querySelectorAll('[id^="list-"]').forEach(el => {
                    // Skip archive - it has its own init
                    if (el.id === 'list-content') return;
                    Sortable.create(el, { ...conf, group: 't' });
                });
                Sortable.create(document.getElementById('archive-content'), { ...conf, group: 't' });
            }
            else {
                ['food', 'household', 'misc', 'trash'].forEach(k => {
                    const el = document.getElementById('cat-' + k);
                    if (el) Sortable.create(el, { ...conf, group: 's' });
                });
            }
            initSectionSortable();
        }

        function switchTab(t) {
            tab = t; const slider = document.getElementById('view-slider'), tB = document.getElementById('tab-tasks'), sB = document.getElementById('tab-shopping');
            slider.style.transition = 'transform 0.4s cubic-bezier(0.16, 1, 0.3, 1)';
            slider.style.transform = t === 'tasks' ? 'translateX(0)' : 'translateX(-100vw)';
            tB.className = t === 'tasks' ? 'px-5 py-2 rounded-lg text-[10px] font-black uppercase bg-blue-600 text-white shadow-lg' : 'px-5 py-2 rounded-lg text-[10px] font-black uppercase text-zinc-500';
            sB.className = t === 'shopping' ? 'px-5 py-2 rounded-lg text-[10px] font-black uppercase bg-blue-600 text-white shadow-lg' : 'px-5 py-2 rounded-lg text-[10px] font-black uppercase text-zinc-500';

            // FAB always visible now!
            // Update placeholders
            const inp = document.getElementById('fab-input');
            if (t === 'tasks') {
                const sec = db.taskSections.find(s => s.id === activeTaskSection);
                inp.placeholder = `Add to ${sec ? sec.title : 'Tasks'}...`;
            } else {
                inp.placeholder = `Add to ${activeShopCat}...`;
            }

            document.getElementById('fab-outer').style.display = '';
            render(false);
            updateFabColor();
        }

        // REVERT: Render with animation enabled (default)
        function toggle(idx) {
            if (idx > -1) {
                db[tab][idx].done = !db[tab][idx].done;
                if (db[tab][idx].done) db[tab][idx].doneAt = Date.now();
                render();
                pushToCloud();
            }
        }
        function remove(idx) {
            if (idx > -1) {
                if (tab === 'shopping') {
                    if (db.shopping[idx].cat === 'trash') {
                        // Restore logic
                        db.shopping[idx].cat = db.shopping[idx].origCat || 'misc';
                        delete db.shopping[idx].origCat;
                    } else {
                        // Trash logic
                        db.shopping[idx].origCat = db.shopping[idx].cat;
                        db.shopping[idx].cat = 'trash';
                    }
                } else {
                    db[tab].splice(idx, 1);
                }
                render(); pushToCloud();
            }
        }
        function toggleCat(k, e) {
            // If clicking the button inside, don't toggle
            if (e && e.target.tagName === 'BUTTON') return;
            db.collapsedStates[k] = !db.collapsedStates[k];
            render(); saveLocal(); pushToCloud();
        }
        function toggleArchive() { db.collapsedStates.archive = !db.collapsedStates.archive; render(); saveLocal(); pushToCloud(); }
        function wipeCompleted() {
            showConfirm('Delete all completed tasks?', () => {
                db.tasks = db.tasks.filter(t => !t.done);
                render();
                pushToCloud();
            });
        }
        function emptyTrash() {
            showConfirm('Empty Trash?', () => {
                db.shopping = db.shopping.filter(i => i.cat !== 'trash');
                render();
                pushToCloud();
            });
        }
        function showConfirm(msg, cb) {
            document.getElementById('modal-msg').innerText = msg;
            const btn = document.getElementById('modal-confirm-btn');
            btn.onclick = () => { cb(); closeModal(); };
            document.getElementById('modal-overlay').classList.add('active');
        }
        function closeModal() {
            document.getElementById('modal-overlay').classList.remove('active');
        }
        function promptSyncID() {
            showPrompt("Sync ID", syncID || "", (id) => {
                if (id) { localStorage.setItem('todo_sync_id', id.trim()); window.location.reload(); }
            });
        }
        function saveLocal() { localStorage.setItem('todo_db', JSON.stringify(db)); }
        function loadLocal() { const s = localStorage.getItem('todo_db'); if (s) db = JSON.parse(s); }

        function showPrompt(msg, val, cb) {
            document.getElementById('prompt-msg').innerText = msg;
            const input = document.getElementById('prompt-input');
            input.value = val || '';
            const btn = document.getElementById('prompt-confirm-btn');
            const submit = () => { cb(input.value); closePrompt(); };
            btn.onclick = submit;
            input.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); submit(); } };
            document.getElementById('prompt-modal-overlay').classList.add('active');
            setTimeout(() => input.focus(), 100);
        }

        function closePrompt() {
            document.getElementById('prompt-modal-overlay').classList.remove('active');
        }

        async function btnFAB(e) {
            if (e && e.stopPropagation) e.stopPropagation();
            const c = document.getElementById('fab-container');
            if (c.classList.contains('expanded')) {
                const i = document.getElementById('fab-input'), v = i.value.trim();
                if (v) {
                    const uid = Math.random(); animateUID = uid;
                    if (tab === 'shopping') {
                        db.shopping.push({ text: v, done: false, uid: uid, cat: activeShopCat || 'misc' });
                    } else {
                        // Use activeTaskSection (which is now an ID)
                        db.tasks.unshift({ text: v, done: false, uid: uid, section: activeTaskSection });
                    }
                    render(); pushToCloud(); i.value = '';
                }
                collapseInput();
            } else { expandInput(); }
        }

        // Section Edit Modal Logic
        let editingSectionId = null;
        let editingSectionColor = '#ffffff';

        function openSectionEdit(secId) {
            const list = tab === 'tasks' ? db.taskSections : db.shopCategories;
            const sec = list.find(s => s.id === secId);
            if (!sec) return;

            editingSectionId = secId;
            editingSectionColor = sec.color || '#ffffff';

            const nameInput = document.getElementById('edit-sec-name');
            nameInput.value = sec.title;
            document.getElementById('edit-sec-color-input').value = editingSectionColor;

            // Highlight selected color
            document.querySelectorAll('.color-btn').forEach(b => {
                b.classList.toggle('selected', b.dataset.color === editingSectionColor);
            });

            document.getElementById('edit-sec-modal').classList.add('active');

            // Setup button handlers
            document.getElementById('save-sec-btn').onclick = saveSection;
            document.getElementById('cancel-sec-btn').onclick = closeEditModal;
            document.getElementById('delete-sec-btn').onclick = deleteSection;

            nameInput.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); saveSection(); } };

            document.querySelectorAll('.color-btn').forEach(b => {
                b.onclick = () => pickColor(b.dataset.color);
            });
            document.getElementById('edit-sec-color-input').onchange = (e) => pickColor(e.target.value);
        }

        function pickColor(color) {
            editingSectionColor = color;
            document.querySelectorAll('.color-btn').forEach(b => {
                b.classList.toggle('selected', b.dataset.color === color);
            });
            document.getElementById('edit-sec-color-input').value = color;
        }

        function saveSection() {
            const list = tab === 'tasks' ? db.taskSections : db.shopCategories;
            const sec = list.find(s => s.id === editingSectionId);
            if (sec) {
                sec.title = document.getElementById('edit-sec-name').value.trim() || sec.title;
                sec.color = editingSectionColor;
                pushToCloud(); render();
            }
            closeEditModal();
        }

        function deleteSection() {
            const list = tab === 'tasks' ? db.taskSections : db.shopCategories;
            if (list.length <= 1) {
                alert("Can't delete the last section!");
                return;
            }

            // Check if section is empty
            const items = tab === 'tasks' ? db.tasks : db.shopping;
            const hasItems = items.some(i => (tab === 'tasks' ? i.section : i.cat) === editingSectionId);

            const doDelete = () => {
                const defaultId = list[0].id;
                if (tab === 'tasks') {
                    db.tasks.forEach(t => { if (t.section === editingSectionId) t.section = defaultId; });
                    db.taskSections = db.taskSections.filter(s => s.id !== editingSectionId);
                    if (activeTaskSection === editingSectionId) activeTaskSection = defaultId;
                } else {
                    db.shopping.forEach(i => { if (i.cat === editingSectionId) i.cat = defaultId; });
                    db.shopCategories = db.shopCategories.filter(c => c.id !== editingSectionId);
                    if (activeShopCat === editingSectionId) activeShopCat = defaultId;
                }
                pushToCloud(); render();
                closeEditModal();
            };

            if (hasItems) {
                const type = tab === 'tasks' ? 'section' : 'category';
                showConfirm(`Delete this ${type}? Items will move to the first one.`, doDelete);
            } else {
                doDelete();
            }
        }

        function closeEditModal() {
            document.getElementById('edit-sec-modal').classList.remove('active');
            editingSectionId = null;
        }

        // Section Reordering
        function initSectionSortable() {
            const isT = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
            const listC = tab === 'tasks' ? document.getElementById('list-content') : document.getElementById('shop-container');
            if (!listC) return;

            if (listC._sortable) listC._sortable.destroy();

            listC._sortable = Sortable.create(listC, {
                animation: 200,
                handle: '.section-header',
                draggable: '.section-block',
                delay: isT ? 800 : 0,
                delayOnTouchOnly: true,
                ghostClass: 'sortable-ghost',
                onStart: () => { window.isDraggingSectionGlobal = true; },
                onEnd: () => {
                    window.isDraggingSectionGlobal = false;
                    const newOrder = [];
                    listC.querySelectorAll('.section-block').forEach(el => {
                        const secId = el.getAttribute('data-sec-id');
                        const list = tab === 'tasks' ? db.taskSections : db.shopCategories;
                        const sec = list.find(s => s.id === secId);
                        if (sec) newOrder.push(sec);
                    });
                    if (tab === 'tasks') db.taskSections = newOrder;
                    else db.shopCategories = newOrder;
                    saveLocal(); pushToCloud();
                }
            });
        }

        function toggleInput(cat, e) {
            e.stopPropagation();
            const c = document.getElementById('fab-container');
            const i = document.getElementById('fab-input');
            if (c.classList.contains('expanded') && activeCat === cat && !i.value.trim()) {
                collapseInput();
            } else {
                expandInput(cat);
            }
        }
        function expandInput() {
            document.getElementById('fab-container').classList.add('expanded');
            const inp = document.getElementById('fab-input');
            const list = tab === 'shopping' ? db.shopCategories : db.taskSections;
            const activeId = tab === 'shopping' ? activeShopCat : activeTaskSection;
            const sec = list.find(s => s.id === activeId);
            inp.placeholder = `Add to ${sec ? sec.title : (tab === 'shopping' ? 'Items' : 'Tasks')}...`;
            updateFabColor();
            setTimeout(() => { inp.focus(); inp.click(); }, 100);
        }

        function updateFabColor() {
            const icon = document.getElementById('fab-icon');
            if (!icon) return;
            let color = '#3b82f6'; // Default blue
            const list = tab === 'tasks' ? db.taskSections : db.shopCategories;
            const activeId = tab === 'tasks' ? activeTaskSection : activeShopCat;
            const sec = list.find(s => s.id === activeId);
            if (sec && sec.color) color = sec.color;
            icon.setAttribute('stroke', color);
        }
        function collapseInput() { document.getElementById('fab-container').classList.remove('expanded'); document.getElementById('fab-input').blur(); }
        function setupInputLogic() {
            window.onkeydown = (e) => {
                if (e.key === 'Escape') return collapseInput();
                if (e.target.tagName === 'INPUT' || e.target.contentEditable === 'true' || e.ctrlKey || e.metaKey) return;
                if (e.key === 'ArrowLeft') return switchTab('tasks'); if (e.key === 'ArrowRight') return switchTab('shopping');
                if (e.key.length === 1) { expandInput(); document.getElementById('fab-input').value = e.key; }
            };
            document.getElementById('fab-input').onkeypress = (e) => {
                if (e.key === 'Enter') {
                    const v = e.target.value.trim();
                    if (v) {
                        const uid = Math.random(); animateUID = uid;
                        if (tab === 'shopping') {
                            db.shopping.push({ text: v, done: false, uid: uid, cat: activeShopCat || 'misc' });
                        } else {
                            db.tasks.unshift({ text: v, done: false, uid: uid, section: activeTaskSection });
                        }
                        render(); pushToCloud();
                    }
                    e.target.value = ''; collapseInput();
                }
            };
        }
        function handleBgClick(e) { if (e.target.id.includes('-pane')) collapseInput(); }
        function updateStatus(done) {
            const el = document.getElementById('sync-status');
            if (!el) return;
            if (!isOnline) {
                el.innerText = pendingSync ? "Offline (Pending)" : "Offline";
                el.className = "sync-indicator status-offline";
            } else if (!done) {
                el.innerText = "Syncing...";
                el.className = "sync-indicator status-offline"; // Use red/yellow while syncing
            } else {
                el.innerText = pendingSync ? "Retry in 5s..." : "Online";
                el.className = `sync-indicator ${pendingSync ? 'status-offline' : 'status-online'}`;
            }
        }
        init();
    </script>
</body>

</html>
