<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0c0c0d">
    <title>To Do List</title>
    <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'/%3E%3C/svg%3E"
        type="image/svg+xml">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap');

        :root {
            --bg: #0c0c0d;
            --surface: #161618;
            --accent: #3b82f6;
            --text-main: #e5e7eb;
            --keyboard-h: 0px;
        }

        html {
            background-color: var(--bg);
        }

        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            margin: 0;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
        }

        header {
            padding-top: env(safe-area-inset-top);
            position: sticky;
            top: 0;
            z-index: 2000;
            background: var(--bg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        #viewport {
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100vw;
        }

        #view-slider {
            display: flex;
            width: 400vw;
            height: 100%;
            will-change: transform;
        }

        .view-pane {
            width: 100vw;
            height: 100%;
            overflow-y: auto;
            padding-bottom: 120px;
            touch-action: pan-y;
        }

        .shopping-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 6px;
            min-height: 80px;
            /* Ensure drop target exists for empty cats */
            padding-bottom: 4px;
        }

        .task-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 6px;
            min-height: 50px;
            padding-bottom: 4px;
        }

        @media (min-width: 768px) {
            .task-grid {
                grid-template-columns: repeat(var(--cols, 1), minmax(0, 1fr));
                width: 100%;
                justify-content: start;
            }

            .cols-wrapper {
                display: flex;
                gap: 30px;
                align-items: start;
                width: fit-content;
                max-width: 100%;
            }

            .main-col {
                display: flex;
                flex-direction: column;
                gap: 0;
                /* Gaps handled by section margins */
                flex: 1 1 0px;
                min-width: 0;
                max-width: 600px;
                min-height: 100px;
                /* Ensure drop target */
            }

            #list-content {
                display: grid;
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 30px;
                align-items: flex-start;
            }

            #dailies-content {
                display: grid;
                grid-template-columns: repeat(3, minmax(0, 1fr));
                gap: 30px;
                align-items: flex-start;
            }
        }

        .section-block {
            display: block;
            width: 100%;
            min-width: 260px;
            break-inside: avoid;
            margin-bottom: 2.5rem;
            content-visibility: auto;
            contain-intrinsic-size: 1px 100px;
        }

        #shopping-pane .section-block,
        #shopping-pane .section-block-static {
            width: 100%;
        }

        /* Sync Status on Menu Button */
        #menu-btn {
            color: #71717a;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #menu-btn.status-online {
            color: #71717a !important;
            filter: none;
        }

        #menu-btn.status-offline {
            color: #ef4444 !important;
            filter: none;
        }

        #menu-btn.status-syncing {
            color: #3b82f6 !important;
            animation: pulse-sync 1.5s infinite;
        }

        /* Hover must come last to override status colors */
        #menu-btn:hover {
            color: #ffffff !important;
        }

        @keyframes pulse-sync {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.6;
                transform: scale(1.1);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .notes-mobile-content {
            padding: 1rem;
            height: calc(100vh - 140px);
            display: flex;
            flex-direction: column;
        }

        #mobile-notes-textarea {
            flex: 1;
            resize: none;
            color: var(--text-main);
            scrollbar-width: none;
        }

        #mobile-notes-textarea::-webkit-scrollbar {
            display: none;
        }

        .section-header {
            font-size: 10px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0.5rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 4px 8px;
            position: relative;
            z-index: 20;
        }

        .item-card {
            background-color: #161618;
            border: 1px solid #2d2d30;
            border-radius: 10px;
            cursor: grab;
            position: relative;
        }

        .done {
            opacity: 0.25 !important;
            filter: grayscale(1);
        }

        .color-food {
            color: #f59e0b;
        }

        .card-food {
            border-color: rgba(245, 158, 11, 0.2);
            background-color: rgba(245, 158, 11, 0.04);
            color: #fcd34d;
        }

        .color-household {
            color: #3b82f6;
        }

        .card-household {
            border-color: rgba(59, 130, 246, 0.2);
            background-color: rgba(59, 130, 246, 0.04);
            color: #93c5fd;
        }


        .color-misc {
            color: #a855f7;
        }

        .card-misc {
            border-color: rgba(168, 85, 247, 0.2);
            background-color: rgba(168, 85, 247, 0.04);
            color: #d8b4fe;
        }

        .color-trash {
            color: #71717a !important;
        }

        .card-trash {
            border-color: rgba(113, 113, 122, 0.2);
            background-color: rgba(113, 113, 122, 0.04);
            color: #71717a;
        }

        .editable-text {
            outline: none;
            word-break: break-word;
            white-space: pre-wrap;
            user-select: text;
            -webkit-user-select: text;
            pointer-events: auto;
            cursor: text;
        }

        .notes-mobile-content {
            height: calc(100vh - 120px);
            padding: 16px;
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        @media (min-width: 768px) {
            .notes-mobile-content {
                padding: 40px;
            }

            #mobile-notes-textarea {
                font-size: 15px !important;
                padding: 40px !important;
                background: rgba(255, 255, 255, 0.02) !important;
                border: 1px solid rgba(255, 255, 255, 0.05) !important;
                border-radius: 12px;
            }
        }

        /* Notes Sidebar Styles */
        .view-pane-flex {
            display: block;
        }

        @media (min-width: 768px) {
            .view-pane-flex {
                display: flex;
                gap: 40px;
                align-items: stretch;
                min-height: calc(100vh - 120px);
            }

            .list-content-side {
                flex: 1;
                min-width: 0;
                position: relative;
                z-index: 1;
                /* Prevent sidebar overlap blocking clicks */
                padding-bottom: 2rem;
            }

            .notes-wrapper {
                width: 320px;
                flex: 0 0 320px;
                position: relative;
                align-self: stretch;
                display: flex;
                flex-direction: column;
            }

            .notes-sidebar {
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                background: #0c0c0d;
                border-left: 1px solid #1c1c1e;
                padding: 1rem;
                display: flex;
                flex-direction: column;
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 50;
            }

            .notes-sidebar.expanded {
                width: 100vw;
                z-index: 9999;
                padding: 2rem;
                /* Right anchor ensures leftward expansion */
            }

            .notes-edge-trigger {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                width: 40px;
                z-index: 60;
                background: transparent;
            }

            .notes-expand-btn {
                position: absolute;
                left: -12px;
                top: 50%;
                transform: translateY(-50%);
                width: 24px;
                height: 48px;
                background: #1c1c1e;
                border: 1px solid #2d2d30;
                border-radius: 6px 0 0 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0;
                transition: opacity 0.2s;
                color: #71717a;
                z-index: 70;
                pointer-events: none;
                /* Block clicks unless visible */
            }

            .notes-edge-trigger:hover~.notes-expand-btn,
            .notes-expand-btn:hover {
                opacity: 1;
                pointer-events: auto;
            }

            .notes-right-trigger {
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 40px;
                z-index: 60;
                background: transparent;
            }

            .notes-collapse-btn {
                position: absolute;
                right: -12px;
                top: 50%;
                transform: translateY(-50%);
                width: 24px;
                height: 48px;
                background: #1c1c1e;
                border: 1px solid #2d2d30;
                border-radius: 0 6px 6px 0;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0;
                transition: opacity 0.2s, transform 0.2s, right 0.2s;
                color: #71717a;
                z-index: 70;
                pointer-events: none;
            }

            .notes-right-trigger:hover~.notes-collapse-btn,
            .notes-collapse-btn:hover {
                opacity: 1;
                pointer-events: auto;
            }

            .notes-sidebar.expanded .notes-expand-btn {
                display: none;
            }

            .notes-sidebar.expanded .notes-collapse-btn {
                display: none;
            }

            .notes-sidebar.collapsed-hidden {
                transform: translateX(100%);
            }

            /* Hide collapse button when not in sidebar state */
            .notes-sidebar.expanded .notes-collapse-btn,
            .notes-sidebar.collapsed-hidden .notes-collapse-btn {
                display: none;
            }

            .notes-sidebar.collapsed-hidden .notes-expand-btn {
                opacity: 0;
                pointer-events: auto;
                left: -24px;
                /* Ensure it sticks out from the hidden panel */
                right: auto;
            }

            .notes-sidebar.collapsed-hidden:hover .notes-expand-btn {
                opacity: 1;
            }

            .notes-close-btn {
                position: absolute;
                top: 2rem;
                right: 2rem;
                width: 40px;
                height: 40px;
                background: #1c1c1e;
                border: 1px solid #2d2d30;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                color: #ffffff;
                z-index: 10001;
                transition: opacity 0.3s ease, transform 0.2s, background 0.2s;
                opacity: 0;
                pointer-events: none;
            }

            .notes-close-btn:hover {
                background: #27272a;
                transform: scale(1.1);
            }

            .notes-sidebar.expanded .notes-close-btn {
                opacity: 1;
                pointer-events: auto;
            }
        }

        @media (max-width: 767px) {

            .notes-wrapper,
            .notes-sidebar {
                display: none;
            }
        }

        .notes-textarea {
            width: 100%;
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: #d1d1d6;
            font-size: 13px;
            line-height: 1.6;
            resize: none;
            font-family: inherit;
        }

        .strikethrough {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .sortable-ghost {
            opacity: 0.3 !important;
            background: #27272a !important;
            border: 2px dashed #3f3f46 !important;
        }

        .sortable-chosen {
            background: #18181b !important;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            transform: scale(1.02);
            z-index: 50;
        }

        .sortable-drag {
            opacity: 0.9 !important;
            transform: scale(1.1);
            cursor: grabbing !important;
            z-index: 10000 !important;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            border: 2px solid #3b82f6 !important;
        }

        #fab-outer {
            position: fixed;
            right: 1rem;
            bottom: calc(1rem + var(--keyboard-h));
            z-index: 100;
            pointer-events: none;
            transition: bottom 0.2s;
        }

        #fab-container {
            pointer-events: auto;
            width: 48px;
            height: 48px;
            background: #1e1e20;
            border: 1px solid #2d2d30;
            border-radius: 24px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #fab-container.expanded {
            width: min(420px, calc(100vw - 32px));
            border-radius: 12px;
            border-color: var(--accent);
        }

        #fab-input {
            display: none;
            opacity: 0;
            width: 100%;
            background: transparent;
            color: white;
            padding: 0 16px;
            outline: none;
            border: none;
            font-size: 16px;
        }

        #fab-container.expanded #fab-input {
            display: block;
            opacity: 1;
        }

        .collapsed-content {
            display: none !important;
        }

        .chevron {
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            font-size: 8px;
            margin-right: 6px;
            display: inline-block;
        }

        .chevron.is-collapsed {
            transform: rotate(-90deg);
        }

        .sync-indicator {
            font-size: 7px;
            font-weight: 800;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .status-online {
            color: #22c55e;
        }

        .status-offline {
            color: #ef4444;
        }

        nav button {
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1) !important;
        }

        nav button:hover {
            filter: brightness(1.2);
            transform: translateY(-1px);
        }

        nav button:active {
            transform: translateY(0) scale(0.95);
        }

        .item-card {
            transition: opacity 0.2s, background-color 0.2s, border-color 0.2s cubic-bezier(0.16, 1, 0.3, 1) !important;
        }

        .item-card:hover {
            filter: brightness(1.1);
            background-color: rgba(255, 255, 255, 0.05) !important;
        }

        .item-card:active {
            filter: brightness(0.9);
        }

        #display-id {
            transition: color 0.2s;
        }

        #display-id:hover {
            color: white;
        }

        #archive-header-row {
            transition: background 0.2s;
            padding: 8px;
            margin: 0 -8px;
            border-radius: 8px;
        }

        #archive-header-row:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .chk-box {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 2px solid #3f3f46;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .drag-handle {
            display: none !important;
        }

        .chk-box:hover {
            border-color: #71717a;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .chk-box.checked:hover {
            background-color: #2563eb;
            border-color: #2563eb;
        }

        .chk-box.checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }

        .chk-box svg {
            pointer-events: none;
        }

        /* Hide FAB in shopping mode unless expanded */
        .hidden-fab:not(.expanded) {
            opacity: 0 !important;
            pointer-events: none !important;
            transform: scale(0.5) !important;
        }

        /* Entry Animation */
        @keyframes itemSlideUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }

            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .item-slide-in {
            animation: itemSlideUp 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            transform-origin: center bottom;
        }

        /* Modal */
        #modal-overlay,
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 30000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        #modal-overlay.active,
        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
            backdrop-filter: blur(2px);
        }

        .modal-box {
            background: #161618;
            border: 1px solid #2d2d30;
            border-radius: 20px;
            padding: 24px;
            width: 85%;
            max-width: 320px;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        }

        #modal-overlay.active .modal-box,
        .modal-overlay.active .modal-box {
            transform: scale(1);
        }

        .modal-title {
            font-size: 16px;
            font-weight: 700;
            color: white;
            margin-bottom: 24px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: filter 0.2s;
        }

        .modal-btn:active {
            filter: brightness(0.8);
        }

        .btn-cancel {
            background: #27272a;
            color: #a1a1aa;
        }

        .btn-confirm {
            background: #dc2626;
            color: white;
        }

        /* FAB Menu */
        #fab-menu {
            position: fixed;
            bottom: calc(70px + var(--keyboard-h));
            right: 1rem;
            background: #18181b;
            border: 1px solid #27272a;
            border-radius: 12px;
            padding: 8px;
            min-width: 180px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px) scale(0.95);
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            transform-origin: bottom right;
        }

        #fab-menu.active {
            display: flex;
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0) scale(1);
        }

        .section-header {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            margin: 0 -10px;
            cursor: pointer;
            transition: background 0.2s, border-radius 0.2s;
            border-radius: 8px;
        }

        .section-header:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .menu-opt {
            text-align: left;
            background: transparent;
            border: none;
            color: #e5e7eb;
            padding: 10px 12px;
            font-size: 13px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.1s, transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .menu-opt:active {
            transform: scale(0.98);
        }

        .menu-opt:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .menu-opt.selected {
            font-weight: 800;
        }

        .hover-highlight {
            background: rgba(255, 255, 255, 0.1) !important;
        }

        .menu-divider {
            height: 1px;
            background: #2d2d30;
            margin: 4px 0;
        }
    </style>
</head>

<body>
    <header style="view-transition-name: main-header" class="flex justify-between items-center px-4 py-2 flex-shrink-0">
        <div class="flex items-center gap-4">
            <button id="menu-btn" onclick="toggleOptionsMenu(event)" class="transition-all duration-300">
                <svg width="24" height="24" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="3">
                    <path d="M4 6h16M4 12h16M4 18h16" />
                </svg>
            </button>
            <nav style="view-transition-name: main-tabs" id="tab-nav"
                class="flex gap-1.5 md:gap-2 bg-zinc-900/80 p-1.5 rounded-xl border border-white/5">
                <button onclick="switchTab('tasks')" id="tab-tasks" data-id="tasks"
                    class="px-4 md:px-6 py-2 rounded-lg text-[10px] font-black uppercase transition-all">Tasks</button>
                <button onclick="switchTab('dailies')" id="tab-dailies" data-id="dailies"
                    class="px-4 md:px-6 py-2 rounded-lg text-[10px] font-black uppercase transition-all">Dailies</button>
                <button onclick="switchTab('shopping')" id="tab-shopping" data-id="shopping"
                    class="px-4 md:px-6 py-2 rounded-lg text-[10px] font-black uppercase transition-all">Shopping</button>
                <button onclick="switchTab('notes')" id="tab-notes" data-id="notes"
                    class="px-4 md:px-6 py-2 rounded-lg text-[10px] font-black uppercase transition-all flex items-center justify-center">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="16" y1="13" x2="8" y2="13"></line>
                        <line x1="16" y1="17" x2="8" y2="17"></line>
                        <polyline points="10 9 9 9 8 9"></polyline>
                    </svg>
                </button>
            </nav>
        </div>
    </header>

    <div id="viewport">
        <div id="view-slider">
            <main id="tasks-pane" class="view-pane px-2 no-scrollbar" onclick="handleBgClick(event)">
                <div class="view-pane-flex">
                    <div class="list-content-side">
                        <div id="list-content" class="cols-wrapper mt-2"></div>
                        <!-- Archive Area now appended dynamically or kept at bottom -->
                        <section id="archive-area" class="hidden mt-6 pt-4 border-t border-zinc-900">
                            <div id="archive-header-row"
                                class="flex items-center justify-between px-2 py-1 rounded-lg cursor-pointer hover:bg-white/5 transition"
                                onclick="toggleArchive()">
                                <div class="flex items-center">
                                    <span id="archive-chevron" class="chevron mr-2 text-zinc-600">â–¼</span>
                                    <span
                                        class="text-[11px] font-bold uppercase tracking-wider text-zinc-500">Completed</span>
                                </div>
                                <button onclick="wipeCompleted(event)" id="wipe-btn" class="trash-icon-btn p-1">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                        <path
                                            d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" />
                                    </svg>
                                </button>
                            </div>
                            <div id="archive-content" class="space-y-1.5"></div>
                        </section>
                    </div>
                    <div class="notes-wrapper">
                        <div class="notes-sidebar"></div>
                    </div>
                </div>
            </main>
            <main id="shopping-pane" class="view-pane px-2 no-scrollbar" onclick="handleBgClick(event)">
                <div id="shop-container" class="mt-2 space-y-6"></div>
            </main>
            <main id="dailies-pane" class="view-pane px-2 no-scrollbar" onclick="handleBgClick(event)">
                <div id="dailies-content" class="cols-wrapper mt-2"></div>
            </main>
            <main id="notes-pane" class="view-pane px-2 no-scrollbar" onclick="handleBgClick(event)">
                <div class="notes-mobile-content mt-2">
                    <textarea id="mobile-notes-textarea"
                        class="w-full bg-transparent text-[14px] leading-relaxed outline-none min-height-[calc(100vh-180px)]"
                        placeholder="Type notes here..."></textarea>
                </div>
            </main>
        </div>
    </div>

    <!-- FAB and Menu -->
    <div id="fab-menu" style="view-transition-name: main-menu;"></div>

    <div id="fab-outer">
        <div id="fab-container">
            <input id="fab-input" type="text" placeholder="Add entry..." autocomplete="off">
            <button id="fab-btn" oncontextmenu="return false;"
                class="h-12 w-12 flex items-center justify-center rounded-full hover:bg-zinc-800 transition"><svg
                    id="fab-icon" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="#3b82f6"
                    stroke-width="3">
                    <path d="M12 5v14M5 12h14" />
                </svg></button>
        </div>
    </div>

    <div id="modal-overlay" onclick="closeModal()">
        <div class="modal-box" onclick="event.stopPropagation()">
            <div id="modal-msg" class="modal-title">Are you sure?</div>
            <div class="modal-actions">
                <button class="modal-btn btn-cancel" onclick="closeModal()">Cancel</button>
                <button id="modal-confirm-btn" class="modal-btn btn-confirm">Delete</button>
            </div>
        </div>
    </div>

    <!-- Help / Tutorial Modal -->
    <div id="help-modal" onclick="closeHelp()" style="view-transition-name: main-help; display: none;"
        class="fixed inset-0 z-[30000] flex items-center justify-center pointer-events-none opacity-0 transition-all duration-300 bg-black/80 backdrop-blur-md">
        <div onclick="event.stopPropagation()"
            class="bg-[#161618] border border-[#2d2d30] rounded-3xl p-8 w-[90%] max-w-[450px] max-h-[85vh] overflow-y-auto scale-95 transition-all duration-300 shadow-2xl">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-2xl font-black text-white uppercase tracking-tighter">Guide</h2>
                <button onclick="closeHelp()" class="text-zinc-500 hover:text-white transition-colors">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="space-y-6 text-zinc-400 text-sm leading-relaxed">
                <section>
                    <h3 class="text-blue-500 font-bold uppercase text-[11px] tracking-widest mb-2">Navigation</h3>
                    <p>Swipe left/right or use arrow keys to switch tabs. Drag tabs in the header to reorder them.</p>
                </section>
                <section>
                    <h3 class="text-green-500 font-bold uppercase text-[11px] tracking-widest mb-2">Tasks</h3>
                    <p>Reorder items within or between sections. Long-press a section header to edit its name or color.
                    </p>
                </section>
                <section>
                    <h3 class="text-teal-500 font-bold uppercase text-[11px] tracking-widest mb-2">Dailies</h3>
                    <p>Tasks that reset automatically. Change a section's recurrence (Daily, Weekly, etc.) by
                        long-pressing its header. Set your preferred Day Reset Time in the menu.</p>
                </section>
                <section>
                    <h3 class="text-orange-500 font-bold uppercase text-[11px] tracking-widest mb-2">Shopping</h3>
                    <p>Items checked off move to Trash. Use the trash icon on the header to wipe them all at once.</p>
                </section>
                <section>
                    <h3 class="text-zinc-500 font-bold uppercase text-[11px] tracking-widest mb-2">Sync</h3>
                    <p>Enter your Sync ID in the menu to access your data on any device in real-time.</p>
                </section>
            </div>
            <button onclick="closeHelp()"
                class="w-full mt-8 bg-zinc-800 text-white py-4 rounded-2xl font-bold hover:bg-zinc-700 transition-colors">Got
                it!</button>
        </div>
    </div>

    <!-- Mobile Notes Modal -->
    <div id="mobile-notes-modal" style="view-transition-name: main-notes; display: none;"
        class="fixed inset-0 z-[30000] flex flex-col bg-[#0c0c0d] pointer-events-none opacity-0 transition-all duration-300">
        <div class="flex items-center justify-between p-4 border-b border-zinc-800">
            <h2 class="text-lg font-bold text-white">Notes</h2>
            <button onclick="closeMobileNotes()" class="text-zinc-500 hover:text-white transition-colors p-2">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                    stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <textarea class="notes-textarea flex-1 p-4" placeholder=""></textarea>
    </div>

    <style>
        #mobile-notes-modal.active {
            display: flex;
            opacity: 1;
            pointer-events: auto;
        }
    </style>

    <!-- Custom Prompt Modal -->
    <div id="prompt-modal-overlay" class="modal-overlay" onclick="closePrompt()" style="display: none;">
        <div class="modal-box" onclick="event.stopPropagation()">
            <div id="prompt-msg" class="modal-title">Enter Value</div>
            <input id="prompt-input" type="text"
                class="w-full bg-[#27272a] border border-[#3f3f46] rounded-xl px-4 py-3 text-white mb-6 outline-none focus:border-blue-500 transition-colors">
            <div class="modal-actions">
                <button class="modal-btn btn-cancel flex items-center justify-center" onclick="closePrompt()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
                <button id="prompt-confirm-btn"
                    class="modal-btn btn-confirm !bg-blue-600 flex items-center justify-center">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                        stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Edit Section Modal -->
    <div id="edit-sec-modal" onclick="closeEditModal()" style="display: none;"
        class="fixed inset-0 z-[20000] flex items-center justify-center pointer-events-none opacity-0 transition-opacity duration-200 bg-black/60 backdrop-blur-sm">
        <div onclick="event.stopPropagation()"
            class="bg-[#161618] border border-[#2d2d30] rounded-2xl p-6 w-[85%] max-w-[320px] scale-90 transition-transform duration-200 shadow-2xl">
            <h3 class="text-white font-bold text-lg mb-4 text-center">Edit Section</h3>
            <div class="space-y-4">
                <div>
                    <label class="text-xs text-zinc-500 font-bold uppercase tracking-wider mb-1 block">Name</label>
                    <input id="edit-sec-name" type="text"
                        class="w-full bg-[#27272a] border border-[#3f3f46] rounded-lg px-3 py-2 text-white text-sm focus:outline-none focus:border-blue-500 transition-colors">
                </div>
                <div id="edit-sec-interval-container" class="hidden">
                    <label
                        class="text-xs text-zinc-500 font-bold uppercase tracking-wider mb-1 block">Recurrence</label>
                    <select id="edit-sec-interval"
                        class="w-full bg-[#27272a] border border-[#3f3f46] rounded-lg px-3 py-2 text-white text-sm focus:outline-none focus:border-blue-500 transition-colors">
                        <option value="daily">Daily</option>
                        <option value="weekly">Weekly</option>
                        <option value="bi-weekly">Bi-Weekly</option>
                        <option value="monthly">Monthly</option>
                        <option value="yearly">Yearly</option>
                    </select>
                </div>
                <div>
                    <label class="text-xs text-zinc-500 font-bold uppercase tracking-wider mb-1 block">Color</label>
                    <div class="flex gap-2 justify-center flex-wrap" id="color-opts">
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#ffffff" data-color="#ffffff"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#f87171" data-color="#f87171"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#fbbf24" data-color="#fbbf24"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#4ade80" data-color="#4ade80"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#60a5fa" data-color="#60a5fa"></button>
                        <button
                            class="color-btn w-8 h-8 rounded-full border-2 border-transparent hover:scale-110 transition-transform"
                            style="background:#a78bfa" data-color="#a78bfa"></button>
                        <input type="color" id="edit-sec-color-input"
                            class="w-8 h-8 rounded-full p-0 border-0 overflow-hidden cursor-pointer rainbow-picker">
                    </div>
                </div>
            </div>
            <div class="flex gap-2 mt-6">
                <button id="delete-sec-btn"
                    class="flex-1 flex items-center justify-center bg-red-900/40 text-red-500 py-3 rounded-xl text-sm font-bold hover:bg-red-900/60 transition-colors">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        <line x1="10" y1="11" x2="10" y2="17"></line>
                        <line x1="14" y1="11" x2="14" y2="17"></line>
                    </svg>
                </button>
                <button id="cancel-sec-btn"
                    class="flex-1 flex items-center justify-center bg-[#27272a] text-[#a1a1aa] py-3 rounded-xl text-sm font-bold hover:brightness-110 transition-all">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
                <button id="save-sec-btn"
                    class="flex-1 flex items-center justify-center bg-blue-600 text-white py-3 rounded-xl text-sm font-bold hover:bg-blue-500 transition-colors">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                        stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <style>
        #tab-nav:empty {
            display: none;
        }

        #tab-nav button[style*="display: none"]+button {
            border-left: none;
        }

        #edit-sec-modal.active,
        #help-modal.active {
            display: flex;
            opacity: 1;
            pointer-events: auto;
        }

        #edit-sec-modal.active>div {
            transform: scale(1);
        }

        .color-btn.selected {
            border-color: white !important;
            transform: scale(1.15);
        }

        .drop-highlight {
            background: rgba(59, 130, 246, 0.2) !important;
            box-shadow: inset 0 0 0 2px #3b82f6;
        }

        .hover-highlight {
            background: rgba(255, 255, 255, 0.1) !important;
        }

        .rainbow-picker {
            appearance: none;
            -webkit-appearance: none;
            background: conic-gradient(from 0deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000) !important;
        }

        .rainbow-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .rainbow-picker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
            background: transparent !important;
        }

        /* Consistent trash icon color - removed red hover as requested */
        #wipe-btn,
        .trash-icon-btn {
            color: #71717a !important;
            transition: color 0.2s;
        }

        #wipe-btn:hover,
        .trash-icon-btn:hover {
            color: #a1a1aa !important;
        }

        /* Refined White Flash Suppression & Stabilization */
        html {
            background-color: var(--bg) !important;
        }

        ::view-transition-group(root) {
            animation-duration: 0s !important;
        }

        ::view-transition-old(root),
        ::view-transition-new(root) {
            animation: none !important;
            mix-blend-mode: normal !important;
        }

        /* Keep header and tabs absolutely stable */
        ::view-transition-group(main-header),
        ::view-transition-group(main-tabs) {
            animation-duration: 0s !important;
        }

        /* Force overlays on top during transitions */
        ::view-transition-group(main-menu),
        ::view-transition-group(main-help),
        ::view-transition-group(main-notes) {
            z-index: 10000 !important;
        }
    </style>

    <script>
        // PWA Helper
        // Generate an icon
        const iconSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="background:#0c0c0d"><rect width="24" height="24" fill="#0c0c0d"/><path d="M12 5v14M5 12h14" stroke="#3b82f6" stroke-width="2" stroke-linecap="round"/></svg>`;
        const iconBlob = new Blob([iconSVG], { type: 'image/svg+xml' });
        const iconURL = URL.createObjectURL(iconBlob);

        const manifest = {
            "id": window.location.pathname,
            "name": "To Do List",
            "short_name": "ToDo",
            "start_url": window.location.href,
            "scope": window.location.href,
            "display": "standalone",
            "background_color": "#0c0c0d",
            "theme_color": "#0c0c0d",
            "icons": [
                { "src": iconURL, "sizes": "512x512", "type": "image/svg+xml" },
                { "src": iconURL, "sizes": "192x192", "type": "image/svg+xml" }
            ]
        };
        const linkManifest = document.createElement('link');
        linkManifest.setAttribute('rel', 'manifest');
        linkManifest.setAttribute('href', URL.createObjectURL(new Blob([JSON.stringify(manifest)], { type: 'application/json' })));
        document.head.appendChild(linkManifest);

        // Utility: Wash out color (make subtler/closer to white)
        function wash(hex, amount = 0.5) {
            if (!hex || hex[0] !== '#') return hex;
            if (hex.length === 4) hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            const m = (c) => Math.round(c + (255 - c) * amount);
            const h = (c) => c.toString(16).padStart(2, '0');
            return `#${h(m(r))}${h(m(g))}${h(m(b))}`;
        }

        function updateGridColumns(container, items) {
            if (!container || !items) return;
            const maxLen = Math.max(0, ...items.map(i => (i.text || '').length));
            let cols = 1;
            if (items.length > 1) {
                if (maxLen < 20) cols = 3;
                else if (maxLen < 35) cols = 2;
            }
            container.style.setProperty('--cols', cols);
        }

        let syncID = (localStorage.getItem('todo_sync_id') || '').toLowerCase().trim();
        let isOnline = navigator.onLine;
        let pendingSync = syncID ? (localStorage.getItem(`todo_pending_sync_${syncID}`) === 'true') : false;

        window.addEventListener('online', () => {
            isOnline = true;
            if (pendingSync) {
                console.log("Back online, pushing pending changes...");
                pushToCloud();
            }
        });
        window.addEventListener('offline', () => {
            isOnline = false;
            updateStatus(true); // Refresh UI to show offline
        });

        if ('serviceWorker' in navigator && window.location.protocol.startsWith('http')) {
            navigator.serviceWorker.register(
                URL.createObjectURL(new Blob(['self.addEventListener("fetch", (e) => {});'], { type: "text/javascript" })),
                { scope: window.location.href }
            ).catch(err => console.log('SW Error:', err));
        }

        const SB_URL = "https://sbhxqpymyxpxocwnngun.supabase.co", SB_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNiaHhxcHlteXhweG9jd25uZ3VuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc0MjI5NzAsImV4cCI6MjA4Mjk5ODk3MH0.RxtlRPzMaib2_EWxIzHajObzyHxqo0sA66eIWDYk620", supabaseClient = supabase.createClient(SB_URL, SB_KEY);
        // Data Model Update: taskSections & shopCategories
        let db = {
            tasks: [],
            shopping: [],
            dailies: [],
            taskSections: ['Tasks'],
            shopCategories: [],
            dailySections: [
                { id: 'Daily', title: 'Daily', interval: 'daily', color: '#3b82f6' },
                { id: 'Weekly', title: 'Weekly', interval: 'weekly', color: '#10b981' },
                { id: 'Monthly', title: 'Monthly', interval: 'monthly', color: '#8b5cf6' }
            ],
            collapsedStates: { archive: false },
            deleted: [], // Tombstones for deleted items
            settings: {
                tabs: { tasks: true, shopping: true, dailies: true, notes: true },
                tabOrder: ['tasks', 'dailies', 'shopping', 'notes'],
                lastResetDate: null,
                resetTime: 0,
                activeTaskSection: 'Tasks',
                activeShopCat: 'misc',
                activeDailySection: 'Daily',
                notesState: 'sidebar',
                m: Date.now()
            },
            notes: "",
            notesM: 0
        };
        let tab = 'tasks', isRemoteUpdate = false;
        let isDragging = false, panStartX = 0, panStartY = 0, isPanning = false, lastActionTime = 0, animateUID = 0;

        // Active selections
        let activeTaskSection = 'Tasks';
        let activeShopCat = 'misc';
        let activeDailySection = 'Daily';
        let activeNotesState = 'sidebar';

        // Unified Migration Logic
        function mergeDB(local, remote) {
            if (!remote) return migrateDB(local, true);
            // DO NOT update globals during merge
            const l = migrateDB(JSON.parse(JSON.stringify(local)), false);
            const r = migrateDB(JSON.parse(JSON.stringify(remote)), false);

            const mergeArea = (listL, listR, delUnion) => {
                const map = new Map();
                // 1. Collect all valid items from both sides
                const all = [...listR, ...listL];
                all.forEach(i => {
                    const key = i.uid || i.id;
                    if (!key || delUnion.has(key)) return;
                    const existing = map.get(key);
                    if (!existing || (i.m || 0) > (existing.m || 0)) {
                        map.set(key, i);
                    }
                });

                // 2. Decide on order. Prefer the list that has the newest overall modification.
                const maxL = Math.max(0, ...listL.map(i => i.m || 0));
                const maxR = Math.max(0, ...listR.map(i => i.m || 0));
                const preferredOrder = maxL >= maxR ? listL : listR;

                const result = [];
                const seen = new Set();
                preferredOrder.forEach(i => {
                    const key = i.uid || i.id;
                    if (map.has(key)) {
                        result.push(map.get(key));
                        seen.add(key);
                    }
                });
                // Add any orphans
                map.forEach((value, key) => { if (!seen.has(key)) result.push(value); });
                return result;
            };

            const delUnion = new Set([...l.deleted, ...r.deleted]);

            const merged = {
                tasks: mergeArea(l.tasks, r.tasks, delUnion),
                shopping: mergeArea(l.shopping, r.shopping, delUnion),
                dailies: mergeArea(l.dailies, r.dailies, delUnion),
                taskSections: mergeArea(l.taskSections, r.taskSections, delUnion),
                shopCategories: mergeArea(l.shopCategories, r.shopCategories, delUnion),
                dailySections: mergeArea(l.dailySections, r.dailySections, delUnion),
                deleted: Array.from(delUnion).slice(-100),
                collapsedStates: { ...r.collapsedStates, ...l.collapsedStates },
                settings: (l.settings?.m || 0) > (r.settings?.m || 0) ? l.settings : r.settings,
                notes: (l.settings?.m || 0) > (r.settings?.m || 0) ? l.notes : r.notes // Use settings timestamp as proxy for notes freshness for now, or just prefer local
            };
            // Better notes merge: if notes exist on both, pick the one from the side with the newest overall modification
            const latestM = Math.max(l.settings?.m || 0, r.settings?.m || 0);
            merged.notes = (l.settings?.m || 0) >= (r.settings?.m || 0) ? (l.notes || "") : (r.notes || "");
            // Better notes merge: use independent timestamp
            const lNm = l.notesM || l.settings?.m || 0;
            const rNm = r.notesM || r.settings?.m || 0;
            merged.notes = lNm >= rNm ? (l.notes || "") : (r.notes || "");
            merged.notesM = Math.max(lNm, rNm);
            return merged;
        }

        function migrateDB(data, updateGlobals = true) {
            if (!data) data = {};
            if (!data.tasks) data.tasks = [];
            if (!data.shopping) data.shopping = [];

            // Dailies Array
            if (!data.dailies) data.dailies = [];

            // Task Sections
            if (!data.taskSections || data.taskSections.length === 0) data.taskSections = [{ id: 'Tasks', title: 'Tasks', color: '#ffffff' }];
            data.taskSections = data.taskSections.map(s => typeof s === 'string' ? { id: s, title: s, color: '#ffffff' } : s);

            // Daily Sections
            if (!data.dailySections || data.dailySections.length === 0 || (data.dailySections.length === 1 && data.dailySections[0].id === 'Dailies')) {
                data.dailySections = [
                    { id: 'Daily', title: 'Daily', interval: 'daily', color: '#3b82f6' },
                    { id: 'Weekly', title: 'Weekly', interval: 'weekly', color: '#10b981' },
                    { id: 'Monthly', title: 'Monthly', interval: 'monthly', color: '#8b5cf6' }
                ];
                // Move old items
                data.dailies.forEach(d => { if (d.section === 'Dailies' || !d.section) d.section = 'Daily'; });
            }
            data.dailySections = data.dailySections.map(s => typeof s === 'string' ? { id: s, title: s, color: '#ffffff', interval: 'daily' } : s);

            // Ensure every item has a UID (Critical for Merging)
            const ensureUID = (list) => list.forEach(i => { if (!i.uid) i.uid = Math.random(); });
            ensureUID(data.tasks); ensureUID(data.shopping); ensureUID(data.dailies);

            // Daily Items Migration
            data.dailies.forEach(d => {
                if (!d.section) d.section = 'Daily';
                if (d.section === 'Dailies' && !data.dailySections.some(s => s.id === 'Dailies')) d.section = 'Daily';
            });

            // Shopping Categories
            if (!data.shopCategories || data.shopCategories.length === 0) {
                data.shopCategories = [
                    { id: 'food', title: 'Food', color: '#f59e0b' },
                    { id: 'household', title: 'Household', color: '#3b82f6' },
                    { id: 'misc', title: 'Misc', color: '#a855f7' }
                ];
            }
            data.shopCategories = data.shopCategories.map(c => typeof c === 'string' ? { id: c, title: c, color: '#ffffff' } : c);

            // Collapsed States
            if (!data.collapsedStates) data.collapsedStates = { archive: false };
            data.taskSections.forEach(s => { if (data.collapsedStates[s.id] === undefined) data.collapsedStates[s.id] = false; });
            data.shopCategories.forEach(c => { if (data.collapsedStates[c.id] === undefined) data.collapsedStates[c.id] = false; });
            data.dailySections.forEach(s => { if (data.collapsedStates[s.id] === undefined) data.collapsedStates[s.id] = false; });

            if (data.notes === undefined) data.notes = "";
            if (data.notesM === undefined) data.notesM = data.settings?.m || 0;

            // Settings & Tabs
            if (!data.settings) data.settings = { tabs: { tasks: true, shopping: true, dailies: true, notes: true }, tabOrder: ['tasks', 'dailies', 'shopping', 'notes'], resetTime: 0, activeTaskSection: 'Tasks', activeShopCat: 'misc', activeDailySection: 'Daily', notesState: 'sidebar' };
            if (!data.settings.tabs) data.settings.tabs = { tasks: true, shopping: true, dailies: true, notes: true };
            if (data.settings.tabs.notes === undefined) data.settings.tabs.notes = true;
            if (!data.settings.tabOrder) data.settings.tabOrder = ['tasks', 'dailies', 'shopping', 'notes'];
            if (!data.settings.tabOrder.includes('notes')) data.settings.tabOrder.push('notes');
            if (data.settings.resetTime === undefined) data.settings.resetTime = 0;
            if (data.settings.activeTaskSection === undefined) data.settings.activeTaskSection = 'Tasks';
            if (data.settings.activeShopCat === undefined) data.settings.activeShopCat = 'misc';
            if (data.settings.activeDailySection === undefined) data.settings.activeDailySection = 'Daily';
            if (data.settings.notesState === undefined) data.settings.notesState = 'sidebar';
            if (data.settings.m === undefined) data.settings.m = 0;

            // Deleted tombstones
            if (!data.deleted) data.deleted = [];

            // Ensure active selections are valid
            if (updateGlobals) {
                activeTaskSection = data.settings.activeTaskSection;
                activeShopCat = data.settings.activeShopCat;
                activeDailySection = data.settings.activeDailySection;
                activeNotesState = data.settings.notesState || 'sidebar';

                if (!data.taskSections.some(s => s.id === activeTaskSection)) activeTaskSection = data.taskSections[0]?.id || 'Tasks';
                if (!data.shopCategories.some(c => c.id === activeShopCat)) activeShopCat = data.shopCategories[0]?.id || 'misc';
                if (!data.dailySections.some(s => s.id === activeDailySection)) activeDailySection = data.dailySections[0]?.id || 'Daily';
            }

            return data;
        }

        function renderTabOrder() {
            const nav = document.getElementById('tab-nav');
            const btns = {
                'tasks': document.getElementById('tab-tasks'),
                'dailies': document.getElementById('tab-dailies'),
                'shopping': document.getElementById('tab-shopping'),
                'notes': document.getElementById('tab-notes')
            };
            db.settings.tabOrder.forEach(id => {
                const b = btns[id];
                if (b) {
                    b.className = id === tab ?
                        'px-4 md:px-6 py-2 rounded-lg text-[10px] font-black uppercase bg-blue-600 text-white shadow-lg transition-all' :
                        'px-4 md:px-6 py-2 rounded-lg text-[10px] font-black uppercase text-zinc-500 transition-all';
                    nav.appendChild(b);
                }
            });
        }

        async function init() {
            // Load local data first so the UI is immediate
            loadLocal();

            // Render immediately with local data
            db = migrateDB(db);
            const initialTab = db.settings.tabOrder.find(t => db.settings.tabs[t]) || 'tasks';
            tab = initialTab;
            renderTabOrder();
            updateTabVisibility();
            switchTab(tab);
            const mobNotes = document.getElementById('mobile-notes-textarea');
            if (mobNotes) mobNotes.value = db.notes || '';
            render(false);

            if (syncID) {
                // Background sync - don't await so UI appears immediately
                (async () => {
                    if (pendingSync && isOnline) {
                        await pushToCloud();
                    } else {
                        await pullFromCloud();
                    }
                    subscribeRealtime();
                })();
            } else {
                setTimeout(promptSyncID, 500);
            }

            // Initial reset check
            checkDailiesReset();

            setupInputLogic(); window.addEventListener('focus', pullFromCloud); setupSwipe(); setupFabGestures(); setupMenuTouch();
            initTabSortable();
            document.getElementById('archive-header-row').onclick = toggleArchive;
            document.getElementById('wipe-btn').onclick = (e) => { e.stopPropagation(); wipeCompleted(); };
        }

        async function pullFromCloud() {
            checkDailiesReset(); // Check reset whenever we might be updating data or returning to app
            if (!syncID || isRemoteUpdate || isDragging || window.isDraggingSectionGlobal) return;
            const { data } = await supabaseClient.from('todos').select('content').eq('sync_id', syncID).maybeSingle();
            if (data?.content) {
                // Perform smart merge
                const merged = mergeDB(db, data.content);
                const changed = JSON.stringify(db) !== JSON.stringify(merged);
                db = merged;

                if (changed) {
                    saveLocal();
                    renderTabOrder();
                    updateTabVisibility();
                    render(false); // Background update, no animation
                }
                updateStatus(true);
            } else { await pushToCloud(); }
        }

        async function pushToCloud() {
            if (!syncID || isRemoteUpdate) return;
            saveLocal();
            if (!isOnline) {
                pendingSync = true;
                if (syncID) localStorage.setItem(`todo_pending_sync_${syncID}`, 'true');
                updateStatus(true);
                return;
            }

            updateStatus(false);
            if (window._pushDebounce) clearTimeout(window._pushDebounce);
            window._pushDebounce = setTimeout(async () => {
                try {
                    const { data } = await supabaseClient.from('todos').select('content').eq('sync_id', syncID).maybeSingle();
                    const merged = mergeDB(db, data?.content);
                    const { error } = await supabaseClient.from('todos').upsert({ sync_id: syncID, content: merged }, { onConflict: 'sync_id' });

                    if (error) {
                        console.warn("Push error:", error);
                        pendingSync = true;
                        if (syncID) localStorage.setItem(`todo_pending_sync_${syncID}`, 'true');
                        updateStatus(true);
                        return;
                    }

                    db = merged;
                    saveLocal();
                    pendingSync = false;
                    if (syncID) localStorage.setItem(`todo_pending_sync_${syncID}`, 'false');
                    updateStatus(true);
                    render(false);
                } catch (e) {
                    console.error("Sync exception:", e);
                    pendingSync = true;
                    if (syncID) localStorage.setItem(`todo_pending_sync_${syncID}`, 'true');
                    updateStatus(true);
                }
            }, 500);
        }



        function subscribeRealtime() {
            supabaseClient.channel('changes').on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'todos', filter: `sync_id=eq.${syncID}` }, payload => {
                if (isRemoteUpdate || isDragging) return;
                isRemoteUpdate = true;
                const remoteDB = payload.new.content;
                db = mergeDB(db, remoteDB); // Use smart merge on incoming changes too
                renderTabOrder();
                updateTabVisibility();
                render(false);
                isRemoteUpdate = false;
            }).subscribe();
        }

        function setupSwipe() {
            // ... (keeping existing swipe logic, just need to make sure I don't break it)
            const vp = document.getElementById('viewport'), slider = document.getElementById('view-slider');
            vp.addEventListener('touchstart', e => { if (isDragging) return; panStartX = e.touches[0].clientX; panStartY = e.touches[0].clientY; isPanning = false; slider.style.transition = 'none'; }, { passive: true });
            vp.addEventListener('touchmove', e => {
                if (isDragging) return;
                let dx = e.touches[0].clientX - panStartX, dy = e.touches[0].clientY - panStartY;
                if (!isPanning && Math.abs(dx) > 25 && Math.abs(dx) > Math.abs(dy)) {
                    const enabledTabs = db.settings.tabOrder.filter(t => db.settings.tabs[t]);
                    const idx = enabledTabs.indexOf(tab);
                    // Prevent swiping past boundaries
                    if ((idx === 0 && dx > 0) || (idx === enabledTabs.length - 1 && dx < 0)) {
                        // Don't pan if there's no page in that direction
                    } else if (enabledTabs.length > 1) {
                        isPanning = true;
                    }
                }
                if (isPanning) {
                    const enabledTabs = db.settings.tabOrder.filter(t => db.settings.tabs[t]);
                    const idx = enabledTabs.indexOf(tab);
                    const offset = idx * -window.innerWidth;
                    slider.style.transform = `translateX(${offset + dx}px)`;
                }
            }, { passive: true });
            vp.addEventListener('touchend', e => {
                if (isDragging) return;
                slider.style.transition = 'transform 0.4s cubic-bezier(0.16, 1, 0.3, 1)';
                if (isPanning) {
                    let dx = e.changedTouches[0].clientX - panStartX;
                    // Increased threshold to 80px for stability
                    if (Math.abs(dx) > 80) {
                        const enabledTabs = db.settings.tabOrder.filter(t => db.settings.tabs[t]);
                        const idx = enabledTabs.indexOf(tab);
                        if (dx > 0) {
                            const prev = enabledTabs[idx - 1];
                            if (prev) switchTab(prev);
                            else switchTab(tab);
                        } else {
                            const next = enabledTabs[idx + 1];
                            if (next) switchTab(next);
                            else switchTab(tab);
                        }
                    } else switchTab(tab);
                }
                isPanning = false;
            }, { passive: true });

            // Touchpad Swipe Support
            let wheelLastTime = 0;
            vp.addEventListener('wheel', e => {
                const now = Date.now();
                if (now - wheelLastTime < 300) return; // Cooldown
                if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && Math.abs(e.deltaX) > 10) {
                    const enabledTabs = db.settings.tabOrder.filter(t => db.settings.tabs[t]);
                    const idx = enabledTabs.indexOf(tab);
                    if (e.deltaX > 0) {
                        const next = enabledTabs[idx + 1];
                        if (next) switchTab(next);
                    } else {
                        const prev = enabledTabs[idx - 1];
                        if (prev) switchTab(prev);
                    }
                    wheelLastTime = now;
                }
            }, { passive: true });
        }

        // FAB Gesture Logic
        let fabTimer = null;
        let fabMenuVisible = false;
        let fabMenuJustOpened = false; // Prevents immediate close

        function setupFabGestures() {
            const btn = document.getElementById('fab-btn');

            const startPress = () => {
                fabTimer = setTimeout(() => {
                    fabTimer = null;
                    fabMenuVisible = true;
                    fabMenuJustOpened = true;
                    showFabMenu();
                    if (navigator.vibrate) navigator.vibrate(50);
                    // Reset flag after a short delay
                    setTimeout(() => { fabMenuJustOpened = false; }, 200);
                }, 500);
            };

            const endPress = () => {
                if (fabTimer) {
                    // Released before timer = short click
                    clearTimeout(fabTimer);
                    fabTimer = null;
                    btnFAB();
                }
                // If menu just opened, don't do anything - let it stay open
            };

            btn.addEventListener('touchstart', startPress, { passive: true });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); endPress(); });
            btn.addEventListener('mousedown', startPress);
            btn.addEventListener('mouseup', endPress);
            btn.addEventListener('mouseleave', () => { if (fabTimer) { clearTimeout(fabTimer); fabTimer = null; } });
            // Prevent click event from bubbling when menu is open
            btn.addEventListener('click', (e) => { if (fabMenuVisible) e.stopPropagation(); });
        }

        function showFabMenu() {
            const m = document.getElementById('fab-menu');
            m.style.display = 'flex';
            const isShop = tab === 'shopping';
            m.innerHTML = '';

            if (isShop) {
                db.shopCategories.forEach((c) => {
                    addMenuOption(m, c.title, c.id === activeShopCat, () => {
                        closeFabMenu();
                    }, c.id, c.color);
                });
                const div = document.createElement('div'); div.className = 'menu-divider'; m.appendChild(div);
                addMenuOption(m, '+ New Category', false, () => {
                    closeFabMenu();
                    showPrompt("New Category Name", "", (n) => {
                        if (n && !db.shopCategories.some(x => x.title === n)) {
                            const newCat = { id: 'cat_' + Date.now(), title: n, color: '#ffffff' };
                            db.shopCategories.push(newCat);
                            activeShopCat = newCat.id;
                            pushToCloud(); render();
                        }
                    });
                });
            } else if (tab === 'dailies') {
                db.dailySections.forEach((s, idx) => {
                    const title = s.title;
                    const id = s.id;
                    const color = s.color || '#ffffff';
                    addMenuOption(m, title, id === activeDailySection, () => {
                        closeFabMenu();
                    }, id, color);
                });
                const div = document.createElement('div'); div.className = 'menu-divider'; m.appendChild(div);
                addMenuOption(m, '+ New Section', false, () => {
                    closeFabMenu();
                    showPrompt("New Section Name", "", (n) => {
                        if (n && !db.dailySections.some(x => x.title === n)) {
                            const newSec = { id: 'sec_' + Date.now(), title: n, color: '#ffffff' };
                            db.dailySections.push(newSec);
                            activeDailySection = newSec.id;
                            pushToCloud(); render();
                        }
                    });
                });
            } else {
                db.taskSections.forEach((s, idx) => {
                    const title = s.title;
                    const id = s.id;
                    const color = s.color || '#ffffff';
                    addMenuOption(m, title, id === activeTaskSection, () => {
                        closeFabMenu();
                    }, id, color);
                });
                const div = document.createElement('div'); div.className = 'menu-divider'; m.appendChild(div);
                addMenuOption(m, '+ New Section', false, () => {
                    closeFabMenu();
                    showPrompt("New Section Name", "", (n) => {
                        if (n && !db.taskSections.some(x => x.title === n)) {
                            const newSec = { id: 'sec_' + Date.now(), title: n, color: '#ffffff' };
                            db.taskSections.push(newSec);
                            activeTaskSection = newSec.id;
                            pushToCloud(); render();
                        }
                    });
                });
            }

            m.classList.add('active');

            // Delay adding click-away listener to prevent immediate close
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!m.contains(e.target)) {
                        closeFabMenu();
                        document.removeEventListener('click', closeHandler);
                    }
                };
                document.addEventListener('click', closeHandler);
            }, 100);
        }

        function closeFabMenu() {
            fabMenuVisible = false;
            const m = document.getElementById('fab-menu');
            m.classList.remove('active');
            setTimeout(() => { if (!m.classList.contains('active')) m.style.display = 'none'; }, 200);
        }

        // Shopping category colors - must match CSS .color-* classes
        const shopColors = { food: '#f59e0b', household: '#3b82f6', misc: '#a855f7' };

        function addMenuOption(p, text, selected, cb, valueToSet = null, color = null) {
            const b = document.createElement('div');
            b.className = `menu-opt ${selected ? 'selected' : ''}`;
            b.innerHTML = `<span>${text}</span>${selected ? '<span>âœ“</span>' : ''}`;

            // Add color to the text itself, not the background - use saturated color as requested
            if (color) {
                b.style.color = color;
            }

            const selectAction = () => {
                if (valueToSet !== null) {
                    if (tab === 'tasks') {
                        activeTaskSection = valueToSet;
                        db.settings.activeTaskSection = valueToSet;
                    } else if (tab === 'dailies') {
                        activeDailySection = valueToSet;
                        db.settings.activeDailySection = valueToSet;
                    } else {
                        activeShopCat = valueToSet;
                        db.settings.activeShopCat = valueToSet;
                    }
                    db.settings.m = Date.now();
                    document.getElementById('fab-input').placeholder = `Add to ${text}...`;
                    updateFabColor();
                    expandInput();
                    saveLocal();
                    pushToCloud();
                }
                cb();
            };

            b.onclick = (e) => { e.stopPropagation(); selectAction(); };

            b.addEventListener('mouseenter', () => {
                if (fabMenuVisible && !fabTimer) {
                    p.querySelectorAll('.menu-opt').forEach(o => o.classList.remove('hover-highlight'));
                    b.classList.add('hover-highlight');
                }
            });

            b.addEventListener('mouseup', (e) => {
                if (fabMenuVisible) {
                    e.stopPropagation();
                    selectAction();
                }
            });
            b._selectAction = selectAction;
            p.appendChild(b);
        }

        function setupMenuTouch() {
            const m = document.getElementById('fab-menu');
            m.addEventListener('touchmove', (e) => {
                if (!fabMenuVisible) return;
                const touch = e.touches[0];
                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                const opt = el?.closest('.menu-opt');
                if (opt) {
                    m.querySelectorAll('.menu-opt').forEach(o => o.classList.remove('hover-highlight'));
                    opt.classList.add('hover-highlight');
                }
            }, { passive: true });
            m.addEventListener('touchend', (e) => {
                if (!fabMenuVisible) return;
                const touch = e.changedTouches[0];
                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                const opt = el?.closest('.menu-opt');
                if (opt && opt._selectAction) {
                    e.preventDefault(); // Suppress synthetic click to prevent immediate modal close
                    opt._selectAction();
                }
                m.querySelectorAll('.menu-opt').forEach(o => o.classList.remove('hover-highlight'));
            });
        }

        function render(animate = true) {
            if (animate && document.startViewTransition) {
                document.startViewTransition(() => _render());
            } else {
                _render();
            }
        }

        function getISOWeek(d) {
            const date = new Date(d.getTime());
            date.setHours(0, 0, 0, 0);
            date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
            const week1 = new Date(date.getFullYear(), 0, 4);
            return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
        }

        function getLocalDayString(date) {
            const d = new Date(date);
            return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
        }

        function checkDailiesReset() {
            const now = new Date();
            const resetHour = db.settings.resetTime || 0;

            // Adjust "now" to the start of the current "reset day" (effectively shifting timezone)
            const adjustedNow = new Date(now);
            adjustedNow.setHours(adjustedNow.getHours() - resetHour);

            const todayStr = getLocalDayString(adjustedNow);
            const currentWeek = adjustedNow.getFullYear() + '-W' + getISOWeek(adjustedNow);
            const currentMonth = adjustedNow.getFullYear() + '-' + String(adjustedNow.getMonth() + 1).padStart(2, '0');

            let changed = false;

            // DAILY RESET
            if (db.settings.lastDailyReset !== todayStr) {
                db.dailies.forEach(item => {
                    const sec = db.dailySections.find(s => s.id === item.section);
                    const interval = sec ? (sec.interval || 'daily') : 'daily';
                    if (interval === 'daily') item.done = false;
                });
                db.settings.lastDailyReset = todayStr;
                changed = true;
            }

            // WEEKLY RESET
            if (db.settings.lastWeeklyReset !== currentWeek) {
                db.dailies.forEach(item => {
                    const sec = db.dailySections.find(s => s.id === item.section);
                    const interval = sec ? (sec.interval || 'daily') : 'daily';
                    if (interval === 'weekly' || interval === 'bi-weekly') {
                        item.done = false;
                    }
                });
                db.settings.lastWeeklyReset = currentWeek;
                changed = true;
            }

            // MONTHLY RESET
            if (db.settings.lastMonthlyReset !== currentMonth) {
                db.dailies.forEach(item => {
                    const sec = db.dailySections.find(s => s.id === item.section);
                    const interval = sec ? (sec.interval || 'daily') : 'daily';
                    if (interval === 'monthly') item.done = false;
                });
                db.settings.lastMonthlyReset = currentMonth;
                changed = true;
            }

            if (changed) {
                saveLocal(); pushToCloud(); render();
            }
        }

        function _render() {
            const listC = document.getElementById('list-content'), archC = document.getElementById('archive-content'), shopC = document.getElementById('shop-container'), dailyC = document.getElementById('dailies-content');
            if (!listC || !shopC || !dailyC) return;

            // Optimization: Use a fragment or simply manage existing children
            const itemMap = new Map();
            document.querySelectorAll('.item-card').forEach(el => itemMap.set(String(el.getAttribute('data-uid')), el));
            const orphaned = new Set(itemMap.values());

            // Instead of wiping everything, we'll keep what's needed and clear the rest
            const clearContainer = (c) => { if (c) c.innerHTML = ''; };

            const list = db[tab] || [];
            if (!Array.isArray(list)) return;

            const seenUids = new Set();
            const deduplicated = [];
            list.forEach(i => {
                if (!i.uid) i.uid = Math.random();
                const uidStr = String(i.uid);
                if (!seenUids.has(uidStr)) {
                    seenUids.add(uidStr);
                    deduplicated.push(i);
                }
            });
            if (deduplicated.length !== list.length) db[tab] = deduplicated;

            const renderList = deduplicated;
            renderList.forEach(i => { if (tab === 'shopping' && !i.cat) i.cat = 'misc'; });

            if (tab === 'tasks') {
                const archiveArea = document.getElementById('archive-area');
                const isArchCol = db.collapsedStates.archive;
                archiveArea.classList.toggle('is-collapsed', isArchCol);
                document.getElementById('archive-content').classList.toggle('collapsed-content', isArchCol);
                const archChev = document.getElementById('archive-chevron');
                if (archChev) archChev.classList.toggle('is-collapsed', isArchCol);
                archiveArea.classList.remove('hidden');

                // Tasks grouped by section
                // Migrate old string format to new object format
                if (!db.taskSections || db.taskSections.length === 0) db.taskSections = [{ id: 'Tasks', title: 'Tasks', color: '#ffffff' }];
                db.taskSections = db.taskSections.map(s => typeof s === 'string' ? { id: s, title: s, color: '#ffffff' } : s);

                if (!listC.querySelector('#task-col-1')) {
                    listC.innerHTML = '<div id="task-col-1" class="main-col"></div><div id="task-col-2" class="main-col"></div>';
                }
                const colArr = [listC.querySelector('#task-col-1'), listC.querySelector('#task-col-2')];

                db.taskSections.forEach((sec, secIdx) => {
                    const targetCol = colArr[sec.col !== undefined && sec.col < colArr.length ? sec.col : secIdx % 2];
                    const secId = sec.id, secTitle = sec.title, secColor = sec.color || '#ffffff';

                    let secBlock = targetCol.querySelector(`.section-block[data-sec-id="${secId}"]`);
                    if (!secBlock) {
                        secBlock = document.createElement('div');
                        secBlock.className = 'section-block';
                        secBlock.setAttribute('data-sec-id', secId);
                        targetCol.appendChild(secBlock);
                    }

                    const isCol = db.collapsedStates[secId];
                    const count = renderList.filter(i => !i.done && (i.section === secId || (!i.section && secIdx === 0))).length;

                    let hdr = secBlock.querySelector('.section-header');
                    if (!hdr) {
                        hdr = document.createElement('div');
                        hdr.className = 'section-header cursor-pointer hover:bg-white/5 transition-colors rounded-lg px-2 py-1';
                        hdr.setAttribute('data-sec-id', secId);
                        secBlock.prepend(hdr);
                        hdr.onclick = () => toggleCat(secId);
                    }
                    hdr.innerHTML = `<span class="chevron ${isCol ? 'is-collapsed' : ''} mr-2" style="color:${secColor}">â–¼</span>
                        <span class="text-[11px] font-bold uppercase tracking-wider" style="color:${secColor}">${secTitle}</span>
                        <span class="ml-2 text-[9px] opacity-50 bg-zinc-800 px-1.5 py-0.5 rounded-full">${count}</span>`;

                    let cont = secBlock.querySelector('.task-grid');
                    if (!cont) {
                        cont = document.createElement('div'); cont.id = `list-${secId}`; cont.className = `task-grid ${isCol ? 'collapsed-content' : ''}`;
                        secBlock.appendChild(cont);
                    } else { cont.className = `task-grid ${isCol ? 'collapsed-content' : ''}`; }

                    const items = renderList.filter(i => !i.done && (i.section === secId || (secIdx === 0 && !i.section)));
                    items.forEach(i => orphaned.delete(buildItem(cont, i, itemMap)));
                    updateGridColumns(cont, items);
                });

                const comp = renderList.filter(i => i.done).sort((a, b) => (b.doneAt || 0) - (a.doneAt || 0));
                comp.forEach(i => orphaned.delete(buildItem(archC, i, itemMap)));
                updateGridColumns(archC, comp);
                archiveArea.classList.toggle('hidden', comp.length === 0);
            } else if (tab === 'dailies') {
                if (!dailyC.querySelector('#daily-col-1')) {
                    dailyC.innerHTML = '<div id="daily-col-1" class="main-col"></div><div id="daily-col-2" class="main-col"></div><div id="daily-col-3" class="main-col"></div>';
                }
                const colArr = [dailyC.querySelector('#daily-col-1'), dailyC.querySelector('#daily-col-2'), dailyC.querySelector('#daily-col-3')];
                db.dailySections.forEach((sec, secIdx) => {
                    const targetCol = colArr[sec.col !== undefined && sec.col < colArr.length ? sec.col : secIdx % 3];
                    renderDailiesSection(targetCol, sec.title, sec.id, sec.color || '#ffffff', itemMap, secIdx === 0, orphaned);
                });
            } else if (tab === 'shopping') {
                renderShop(shopC, itemMap, orphaned);
            }

            orphaned.forEach(el => el.remove());
            saveLocal(); initSortable(); initSectionSortable(); animateUID = 0;
            renderNotes();
        }

        function renderNotes() {
            const sidebars = document.querySelectorAll('.notes-sidebar');
            sidebars.forEach(sidebar => {
                if (!sidebar.querySelector('.notes-textarea')) {
                    sidebar.innerHTML = `
                        <div class="notes-edge-trigger"></div>
                        <div class="notes-right-trigger"></div>
                        <button class="notes-expand-btn" title="Expand">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="15 18 9 12 15 6"></polyline>
                            </svg>
                        </button>
                        <button class="notes-collapse-btn" title="Collapse">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                        </button>
                        <button class="notes-close-btn" title="Close">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                        <textarea class="notes-textarea" placeholder=""></textarea>
                    `;

                    // Apply initial state
                    if (activeNotesState === 'expanded') sidebar.classList.add('expanded');
                    if (activeNotesState === 'collapsed-hidden') sidebar.classList.add('collapsed-hidden');

                    const expandBtn = sidebar.querySelector('.notes-expand-btn');
                    const collapseBtn = sidebar.querySelector('.notes-collapse-btn');
                    const closeBtn = sidebar.querySelector('.notes-close-btn');
                    const textarea = sidebar.querySelector('.notes-textarea');

                    const updateState = () => {
                        activeNotesState = sidebar.classList.contains('expanded') ? 'expanded' :
                            (sidebar.classList.contains('collapsed-hidden') ? 'collapsed-hidden' : 'sidebar');
                        db.settings.notesState = activeNotesState;
                        db.settings.m = Date.now();
                        saveLocal(); pushToCloud();
                    };

                    expandBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (sidebar.classList.contains('collapsed-hidden')) {
                            sidebar.classList.remove('collapsed-hidden');
                        } else {
                            sidebar.classList.add('expanded');
                        }
                        updateState();
                    };
                    collapseBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (sidebar.classList.contains('expanded')) {
                            sidebar.classList.remove('expanded');
                        } else if (sidebar.classList.contains('collapsed-hidden')) {
                            sidebar.classList.remove('collapsed-hidden');
                        } else {
                            sidebar.classList.add('collapsed-hidden');
                        }
                        updateState();
                    };
                    closeBtn.onclick = (e) => {
                        e.stopPropagation();
                        sidebar.classList.remove('expanded');
                        updateState();
                    };

                    textarea.oninput = (e) => handleNoteInput(e.target.value);

                    // Mouse movement for buttons
                    sidebar.addEventListener('mousemove', (e) => {
                        const isExpanded = sidebar.classList.contains('expanded');
                        const rect = sidebar.getBoundingClientRect();
                        const y = e.clientY - rect.top;
                        const minY = 40, maxY = rect.height - 40;
                        const clampedY = Math.max(minY, Math.min(maxY, y));

                        // Left Side (Expand)
                        if (!isExpanded) {
                            expandBtn.style.top = clampedY + 'px';
                            expandBtn.style.transform = 'translateY(-50%)';
                        }
                        // Right Side (Collapse)
                        collapseBtn.style.top = clampedY + 'px';
                        const isHidden = sidebar.classList.contains('collapsed-hidden');
                        const rot = (isExpanded || isHidden) ? ' rotate(180deg)' : '';
                        collapseBtn.style.transform = `translateY(-50%)${rot}`;
                    });
                }
            });

            // Sync ALL visible notes textareas
            const allNotesAreas = document.querySelectorAll('.notes-textarea, #mobile-notes-textarea');
            allNotesAreas.forEach(ta => {
                if (ta !== document.activeElement && ta.value !== (db.notes || '')) {
                    ta.value = db.notes || '';
                }
                // Ensure oninput is attached if not already (for #mobile-notes-textarea)
                if (!ta.oninput) {
                    ta.oninput = (e) => handleNoteInput(e.target.value);
                }
            });
        }

        function handleNoteInput(val) {
            db.notes = val;
            db.notesM = Date.now();
            db.settings.m = Date.now();
            saveLocal();
            if (window.notesPushTimer) clearTimeout(window.notesPushTimer);
            window.notesPushTimer = setTimeout(() => { pushToCloud(); }, 2000);

            // Sync other textareas immediately (except the one being typed in)
            const allNotesAreas = document.querySelectorAll('.notes-textarea, #mobile-notes-textarea');
            allNotesAreas.forEach(ta => {
                if (ta !== document.activeElement && ta.value !== val) {
                    ta.value = val;
                }
            });
        }

        function renderShop(container, itemMap, orphaned) {
            db.shopCategories.forEach(c => renderSection(container, c.title, c.id, c.color || '#ffffff', itemMap, orphaned));
            if (db.shopping.some(i => i.cat === 'trash')) {
                renderSection(container, 'Trash', 'trash', '#71717a', itemMap, orphaned, false);
            }
        }

        function renderSection(p, l, k, color, itemMap, orphaned, draggable = true) {
            const items = db.shopping.filter(i => i.cat === k);
            const t = items.length, active = items.filter(i => !i.done).length;
            let con = p.querySelector(`.section-block[data-sec-id="${k}"]`) || p.querySelector(`.section-block-static[data-sec-id="${k}"]`);
            if (!con) {
                con = document.createElement('div');
                con.className = draggable ? 'section-block' : 'section-block-static';
                con.setAttribute('data-sec-id', k);
                p.appendChild(con);
            }

            let actionBtn = '';
            if (k === 'trash' && t > 0) {
                actionBtn = `<button class="trash-btn ml-auto md:ml-2 text-zinc-600 hover:text-red-500 p-2 z-10" onclick="event.preventDefault(); event.stopPropagation(); emptyTrash();"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events:none;"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>`;
            }

            const countDisplay = k === 'trash' ? `(${t})` : `(${active}/${t})`;
            const isCol = db.collapsedStates[k];

            let hdr = con.querySelector('.section-header');
            if (!hdr) {
                hdr = document.createElement('div');
                hdr.className = `section-header ${!draggable ? 'no-drag' : ''}`;
                hdr.setAttribute('data-sec-id', k);
                con.prepend(hdr);
                if (k !== 'trash') {
                    let secTimer = null, startX = 0, startY = 0;
                    const sp = (e) => { if (e.type === 'touchstart') { startX = e.touches[0].clientX; startY = e.touches[0].clientY; } secTimer = setTimeout(() => { if (!window.isDraggingSectionGlobal) { secTimer = null; openSectionEdit(k); if (navigator.vibrate) navigator.vibrate(50); } }, 800); };
                    const cp = (e) => { if (e && e.type === 'touchmove') { const x = e.touches[0].clientX, y = e.touches[0].clientY; if (Math.abs(x - startX) < 10 && Math.abs(y - startY) < 10) return; } if (secTimer) { clearTimeout(secTimer); secTimer = null; } };
                    hdr.addEventListener('touchstart', sp, { passive: true }); hdr.addEventListener('touchmove', cp, { passive: true }); hdr.addEventListener('touchend', cp); hdr.addEventListener('mousedown', sp); hdr.addEventListener('mouseup', cp); hdr.addEventListener('mouseleave', cp);
                    hdr.addEventListener('dragstart', () => { window.isDraggingSectionGlobal = true; cp(); });
                }
            }
            hdr.style.color = color;
            hdr.innerHTML = `<div class="flex items-center flex-1 md:flex-initial" onclick="toggleCat('${k}', event)">
                    <span class="chevron ${isCol ? 'is-collapsed' : ''}">â–¼</span>${l} 
                    <span class="ml-1 opacity-60">${countDisplay}</span>
                </div>
                ${actionBtn}`;

            let g = con.querySelector('.shopping-grid');
            if (!g) {
                g = document.createElement('div'); g.id = `cat-${k}`; g.setAttribute('data-cat', k);
                g.className = `shopping-grid ${isCol ? 'collapsed-content' : ''}`;
                con.appendChild(g);
            } else { g.className = `shopping-grid ${isCol ? 'collapsed-content' : ''}`; }

            items.forEach(i => orphaned.delete(buildItem(g, i, itemMap)));
        }

        function renderDailiesSection(p, l, k, color, itemMap, isDefault, orphaned) {
            let secBlock = p.querySelector(`.section-block[data-sec-id="${k}"]`);
            if (!secBlock) {
                secBlock = document.createElement('div');
                secBlock.className = 'section-block';
                secBlock.setAttribute('data-sec-id', k);
                p.appendChild(secBlock);
            }
            const isCol = db.collapsedStates[k];
            const items = db.dailies.filter(i => i.section === k || (isDefault && !i.section));
            const count = items.length;
            const active = items.filter(i => !i.done).length;

            let hdr = secBlock.querySelector('.section-header');
            if (!hdr) {
                hdr = document.createElement('div');
                hdr.className = 'section-header rounded-lg px-2 py-1';
                hdr.setAttribute('data-sec-id', k);
                secBlock.prepend(hdr);
                hdr.oncontextmenu = (e) => { e.preventDefault(); openSectionEdit(k); };
                let secTimer = null, startX = 0, startY = 0;
                const sp = (e) => { if (e.type === 'touchstart') { startX = e.touches[0].clientX; startY = e.touches[0].clientY; } secTimer = setTimeout(() => { if (!window.isDraggingSectionGlobal) { secTimer = null; openSectionEdit(k); if (navigator.vibrate) navigator.vibrate(50); } }, 800); };
                const cp = (e) => { if (e && e.type === 'touchmove') { const x = e.touches[0].clientX, y = e.touches[0].clientY; if (Math.abs(x - startX) < 10 && Math.abs(y - startY) < 10) return; } if (secTimer) { clearTimeout(secTimer); secTimer = null; } };
                hdr.addEventListener('touchstart', sp, { passive: true }); hdr.addEventListener('touchmove', cp, { passive: true }); hdr.addEventListener('touchend', cp); hdr.addEventListener('mousedown', sp); hdr.addEventListener('mouseup', cp); hdr.addEventListener('mouseleave', cp);
                hdr.addEventListener('dragstart', () => { window.isDraggingSectionGlobal = true; cp(); });
            }
            hdr.innerHTML = `<div class="flex items-center flex-1" onclick="toggleCat('${k}', event)">
                    <span class="chevron ${isCol ? 'is-collapsed' : ''} mr-2" style="color:${color}">â–¼</span>
                    <span class="text-[11px] font-bold uppercase tracking-wider" style="color:${color}">${l}</span>
                    <span class="ml-2 text-[9px] opacity-50 bg-zinc-800 px-1.5 py-0.5 rounded-full">${active}/${count}</span>
                </div>`;

            let cont = secBlock.querySelector('.task-grid');
            if (!cont) {
                cont = document.createElement('div'); cont.id = `list-${k}`;
                cont.className = `task-grid ${isCol ? 'collapsed-content' : ''}`;
                secBlock.appendChild(cont);
            } else {
                cont.className = `task-grid ${isCol ? 'collapsed-content' : ''}`;
            }
            items.forEach(i => orphaned.delete(buildItem(cont, i, itemMap)));
            updateGridColumns(cont, items);
        }

        function buildItem(p, i, itemMap) {
            let card = itemMap ? itemMap.get(String(i.uid)) : null;
            const isShop = tab === 'shopping', isDailies = tab === 'dailies';
            const list = isShop ? db.shopCategories : (isDailies ? db.dailySections : db.taskSections);
            const id = isShop ? i.cat : (i.section || list[0].id);
            const sec = list.find(s => s.id === id);

            let rawColor = '#ffffff';
            if (sec && sec.color) rawColor = sec.color;
            if (i.cat === 'trash') rawColor = '#71717a';

            const secColor = wash(rawColor, 0.85), borderCol = isShop ? rawColor : wash(rawColor, 0.6), taskTextCol = isShop ? rawColor : secColor;

            if (!card) {
                card = document.createElement('div');
                card.setAttribute('data-uid', i.uid);
                card.onclick = (e) => {
                    const now = Date.now(), currentI = db[tab].find(x => x.uid == card.getAttribute('data-uid'));
                    if (!currentI || (currentI.lastClick && now - currentI.lastClick < 300)) return;

                    const idx = db[tab].findIndex(x => x.uid == currentI.uid), txt = card.querySelector('.editable-text');

                    if (e.target.closest('.del')) remove(idx);
                    else if (currentI.cat === 'trash') return;
                    else {
                        let allowEdit = false;
                        if (isShop) {
                            const rect = card.getBoundingClientRect(), cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
                            if (Math.sqrt(Math.pow(e.clientX - cx, 2) + Math.pow(e.clientY - cy, 2)) < 10) allowEdit = true;
                        } else if (e.target === txt) allowEdit = true;

                        if (allowEdit) { txt.contentEditable = true; txt.focus(); }
                        else if (e.target.closest('.chk-box') || isShop) { currentI.lastClick = now; toggle(idx); }
                    }
                };
            }

            // Only update DOM if needed
            const lastDone = card.getAttribute('data-last-done'), lastText = card.getAttribute('data-last-text'), lastCat = card.getAttribute('data-last-cat');
            const needsFullUpdate = !card.innerHTML || lastDone !== String(i.done) || lastCat !== String(i.cat) || lastText !== i.text;

            card.className = `group item-card ${i.done ? 'done' : ''} ${!isShop ? 'flex items-center p-3' : 'flex flex-col items-center justify-center p-2 h-14 text-center'}`;
            card.style.opacity = (isShop && i.cat === 'trash') ? '0.35' : '';
            card.style.backgroundColor = !i.done ? taskTextCol + '05' : '';
            card.style.borderColor = !i.done ? borderCol + (isShop ? '88' : '1a') : '';
            if (i.uid === animateUID) card.classList.add('item-slide-in');

            if (needsFullUpdate) {
                if (!isShop) {
                    const svg = i.done ? '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4"><path d="M20 6L9 17l-5-5"/></svg>' : '';
                    card.innerHTML = `<div class="chk-box ${i.done ? 'checked' : ''}">${svg}</div><span class="ml-4 flex-1 editable-text text-[14px] font-medium ${i.done ? 'strikethrough' : ''}">${i.text}</span><button class="del ml-2 text-zinc-700 hover:text-zinc-400 opacity-0 group-hover:opacity-100 transition-opacity">âœ•</button>`;
                    const chk = card.querySelector('.chk-box'), txt = card.querySelector('.editable-text');
                    chk.style.borderColor = !i.done ? borderCol + '1a' : '';
                    txt.style.color = !i.done ? taskTextCol : '';
                    txt.onkeydown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); txt.blur(); } e.stopPropagation(); };
                    txt.onblur = () => { txt.contentEditable = false; const idx = db[tab].findIndex(x => x.uid == i.uid); if (idx > -1) { db[tab][idx].text = txt.innerText; db[tab][idx].m = Date.now(); saveLocal(); pushToCloud(); } };
                } else {
                    const delBtn = i.cat === 'trash' ? `<button class="del absolute top-0.5 right-0.5 text-zinc-500 text-[14px] p-1 hover:text-zinc-300 font-bold">ï¼‹</button>` : `<button class="del absolute top-0.5 right-0.5 text-zinc-700 text-[10px] p-1 hover:text-zinc-400">âœ•</button>`;
                    card.innerHTML = `<span class="editable-text text-[11px] font-bold px-1 ${i.done ? 'strikethrough' : ''}" style="color:${i.done ? '' : taskTextCol}">${i.text}</span>${delBtn}`;
                    const txt = card.querySelector('.editable-text');
                    txt.onkeydown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); txt.blur(); } e.stopPropagation(); };
                    txt.onblur = () => { txt.contentEditable = false; const idx = db[tab].findIndex(x => x.uid == i.uid); if (idx > -1) { db[tab][idx].text = txt.innerText; db[tab][idx].m = Date.now(); saveLocal(); pushToCloud(); } };
                }
                card.setAttribute('data-last-done', i.done);
                card.setAttribute('data-last-text', i.text);
                card.setAttribute('data-last-cat', i.cat);
            }

            if (card.parentElement !== p) p.appendChild(card);
            return card;
        }

        function initSortable() {
            const isT = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
            const conf = {
                group: { name: tab, pull: true, put: true },
                animation: 200, ghostClass: 'sortable-ghost', dragClass: 'sortable-drag',
                draggable: '.item-card',
                delay: isT ? 350 : 0, delayOnTouchOnly: true,
                forceFallback: true, fallbackTolerance: 3,
                swapThreshold: 0.6, invertSwap: true,
                filter: '.editable-text, button, .chk-box, .del', preventOnFilter: true,
                onStart: (evt) => {
                    isDragging = true;
                    // Add a class to body to prevent scrolling/swiping during drag
                    document.body.style.overflow = 'hidden';
                },
                onEnd: (evt) => {
                    isDragging = false;
                    document.body.style.overflow = '';

                    // Manual Drop-on-Header detection
                    const touch = evt.originalEvent.changedTouches ? evt.originalEvent.changedTouches[0] : evt.originalEvent;
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    const header = target?.closest('.section-header');

                    if (header && header.hasAttribute('data-sec-id')) {
                        const targetId = header.getAttribute('data-sec-id');
                        const itemUid = evt.item.getAttribute('data-uid');
                        const itemIdx = db[tab].findIndex(i => String(i.uid) === itemUid);

                        if (itemIdx > -1) {
                            const item = db[tab][itemIdx];
                            let changed = false;
                            if (tab === 'shopping' && item.cat !== targetId) {
                                item.cat = targetId;
                                changed = true;
                            } else if (tab === 'tasks' && item.section !== targetId) {
                                item.section = targetId;
                                item.done = false;
                                changed = true;
                            }

                            if (changed) {
                                // Important: move item to the top of its new container in the array
                                item.m = Date.now(); // Tag move
                                db[tab].splice(itemIdx, 1);
                                db[tab].unshift(item);
                                saveLocal(); pushToCloud(); render();
                                return;
                            }
                        }
                    }

                    // Get new order from tab-specific DOM containers
                    let containers = [];
                    if (tab === 'tasks') containers = Array.from(document.querySelectorAll('[id^="list-"]:not(#list-content), #archive-content'));
                    else if (tab === 'dailies') containers = Array.from(document.querySelectorAll('#dailies-pane [id^="list-"]'));
                    else containers = Array.from(document.querySelectorAll('#shopping-pane [id^="cat-"]'));

                    const allCards = [];
                    containers.forEach(c => allCards.push(...c.querySelectorAll('.item-card')));

                    const listRef = [...db[tab]];
                    const newDbList = [];
                    allCards.forEach(el => {
                        const uid = el.getAttribute('data-uid');
                        const item = listRef.find(x => String(x.uid) === uid);
                        if (item) {
                            if (tab === 'tasks') {
                                const parent = el.parentElement;
                                if (parent.id === 'archive-content') {
                                    item.done = true;
                                    if (!item.doneAt) item.doneAt = Date.now();
                                }
                                else {
                                    item.done = false;
                                    const secId = parent.id.replace('list-', '');
                                    item.section = secId;
                                }
                            } else if (tab === 'shopping') {
                                const nC = el.parentElement.getAttribute('data-cat');
                                if (nC) item.cat = nC;
                            } else if (tab === 'dailies') {
                                const nS = el.parentElement.id.replace('list-', '');
                                if (nS) item.section = nS;
                            }
                            newDbList.push(item);
                        }
                    });

                    // Update main database
                    db[tab] = newDbList;
                    // Tag moved items with new timestamp
                    db[tab].forEach(item => item.m = Date.now());
                    saveLocal(); pushToCloud();

                    // Delay render slightly to allow SortableJS to finish its animation
                    setTimeout(() => render(false), 50);
                }
            };
            const listEl = document.getElementById('list-content');
            const itemEl = document.getElementById('archive-content');

            if (tab === 'tasks' || tab === 'dailies') {
                document.querySelectorAll('.task-grid, #archive-content').forEach(el => {
                    // Skip parent containers if they somehow match
                    if (el.id === 'list-content' || el.id === 'dailies-content') return;
                    Sortable.create(el, { ...conf, group: tab.charAt(0) });
                });
            }
            else if (tab === 'shopping') {
                document.querySelectorAll('.shopping-grid').forEach(el => {
                    Sortable.create(el, { ...conf, group: 's' });
                });
            }
            initSectionSortable();
        }

        function switchTab(t) {
            tab = t;
            const slider = document.getElementById('view-slider');
            const tabs = ['tasks', 'dailies', 'shopping', 'notes'];

            // Respect tabOrder
            const enabledTabs = db.settings.tabOrder.filter(id => db.settings.tabs[id]);
            const activeIndex = enabledTabs.indexOf(t);
            const offset = activeIndex * -100;
            slider.style.transform = `translateX(${offset}vw)`;

            // Sync notes textareas if switching to/from notes
            if (t === 'notes') {
                const mobNotes = document.getElementById('mobile-notes-textarea');
                if (mobNotes) mobNotes.value = db.notes || '';
            }

            // Re-order the panes physically to match the offset? 
            // Or just rely on the order in the HTML being fixed and offset being based on that fixed order.
            // If the user reorders the tabs, the physical panes should probably match.
            const panesOrder = {
                'tasks': document.getElementById('tasks-pane'),
                'dailies': document.getElementById('dailies-pane'),
                'shopping': document.getElementById('shopping-pane'),
                'notes': document.getElementById('notes-pane')
            };
            db.settings.tabOrder.forEach(id => {
                if (panesOrder[id]) slider.appendChild(panesOrder[id]);
            });

            // Update tab styles
            db.settings.tabOrder.forEach(id => {
                const btn = document.getElementById('tab-' + id);
                if (btn) {
                    btn.className = id === t ?
                        'px-4 md:px-6 py-2 rounded-lg text-[10px] font-black uppercase bg-blue-600 text-white shadow-lg transition-all' :
                        'px-4 md:px-6 py-2 rounded-lg text-[10px] font-black uppercase text-zinc-500 transition-all';
                }
            });

            // FAB update
            const inp = document.getElementById('fab-input');
            const activeList = tab === 'shopping' ? db.shopCategories : (tab === 'dailies' ? db.dailySections : db.taskSections);
            const activeId = tab === 'shopping' ? activeShopCat : (tab === 'dailies' ? activeDailySection : activeTaskSection);
            const sec = activeList.find(s => s.id === activeId);

            if (inp) {
                inp.placeholder = `Add to ${sec ? sec.title : tab.charAt(0).toUpperCase() + tab.slice(1)}...`;
            }

            document.getElementById('fab-outer').style.display = (tab === 'notes') ? 'none' : '';
            render(false);
            updateTabVisibility();
            updateFabColor();
        }

        function initTabSortable() {
            const nav = document.getElementById('tab-nav');
            if (nav._sortable) nav._sortable.destroy();
            const isTouch = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
            nav._sortable = Sortable.create(nav, {
                animation: 200,
                delay: isTouch ? 200 : 0,
                delayOnTouchOnly: true,
                onEnd: () => {
                    db.settings.tabOrder = Array.from(nav.children).map(btn => btn.dataset.id);
                    db.settings.m = Date.now();
                    saveLocal();
                    pushToCloud();
                    switchTab(tab); // Refresh slider position
                }
            });
        }

        // REVERT: Render with animation enabled (default)
        function toggle(idx) {
            if (idx > -1) {
                db[tab][idx].done = !db[tab][idx].done;
                db[tab][idx].m = Date.now();
                if (db[tab][idx].done) db[tab][idx].doneAt = Date.now();
                render();
                pushToCloud();
            }
        }
        function remove(idx) {
            if (idx > -1) {
                const item = db[tab][idx];
                if (tab === 'shopping') {
                    if (item.cat === 'trash') {
                        // Permanent delete (into tombstones)
                        if (item.uid) db.deleted.push(item.uid);
                        db.shopping.splice(idx, 1);
                    } else {
                        // Trash logic
                        item.origCat = item.cat;
                        item.cat = 'trash';
                        item.m = Date.now();
                    }
                } else {
                    if (item.uid) db.deleted.push(item.uid);
                    db[tab].splice(idx, 1);
                }
                render(); saveLocal(); pushToCloud();
            }
        }
        function toggleCat(k, e) {
            if (e) e.stopPropagation();
            db.collapsedStates[k] = !db.collapsedStates[k];
            render(); saveLocal(); pushToCloud();
        }
        function toggleArchive() { db.collapsedStates.archive = !db.collapsedStates.archive; render(); saveLocal(); pushToCloud(); }
        function wipeCompleted() {
            showConfirm('Delete all completed tasks?', () => {
                db.tasks.forEach(t => { if (t.done && t.uid) db.deleted.push(t.uid); });
                db.tasks = db.tasks.filter(t => !t.done);
                render();
                saveLocal();
                pushToCloud();
            });
        }
        function emptyTrash() {
            showConfirm('Empty Trash?', () => {
                db.shopping.forEach(i => { if (i.cat === 'trash' && i.uid) db.deleted.push(i.uid); });
                db.shopping = db.shopping.filter(i => i.cat !== 'trash');
                render();
                saveLocal();
                pushToCloud();
            });
        }
        function showConfirm(msg, cb, btnText = "Delete") {
            document.getElementById('modal-msg').innerText = msg;
            const btn = document.getElementById('modal-confirm-btn');
            const cancelBtn = document.querySelector('.btn-cancel');

            cancelBtn.style.display = ''; // Show cancel
            btn.innerText = btnText;
            btn.className = `modal-btn btn-confirm ${btnText === 'Delete' ? '!bg-red-600' : '!bg-blue-600'}`;

            btn.onclick = () => { cb(); closeModal(); };
            const overlay = document.getElementById('modal-overlay');
            overlay.style.display = 'flex';
            setTimeout(() => overlay.classList.add('active'), 10);
        }
        function showAlert(msg) {
            document.getElementById('modal-msg').innerText = msg;
            const btn = document.getElementById('modal-confirm-btn');
            const cancelBtn = document.querySelector('.btn-cancel');

            cancelBtn.style.display = 'none'; // Hide cancel
            btn.innerText = "OK";
            btn.className = "modal-btn btn-confirm"; // Keep style or make neutral

            btn.onclick = () => { closeModal(); };
            const overlay = document.getElementById('modal-overlay');
            overlay.style.display = 'flex';
            setTimeout(() => overlay.classList.add('active'), 10);
        }
        function closeModal() {
            const overlay = document.getElementById('modal-overlay');
            overlay.classList.remove('active');
            setTimeout(() => { if (!overlay.classList.contains('active')) overlay.style.display = 'none'; }, 200);
            // Reset state slightly after transition if desired, but not strictly necessary for simple modal
            setTimeout(() => {
                const cancelBtn = document.querySelector('.btn-cancel');
                if (cancelBtn) cancelBtn.style.display = '';
            }, 200);
        }

        // Options Menu (Hamburger)
        // Options Menu (Hamburger)
        function addGenericMenuOption(m, label, enabled, color, cb) {
            const opt = document.createElement('button');
            opt.className = 'menu-opt';
            opt.style.color = '#ffffff';
            const statusCol = enabled ? '#3b82f6' : '#71717a';
            opt.innerHTML = `<span>${label}</span><span class="text-[10px] font-black tracking-tighter ${enabled ? '' : 'opacity-40'}" style="color:${statusCol}">${enabled ? 'ON' : 'OFF'}</span>`;
            opt.onclick = (e) => { e.stopPropagation(); cb(); };
            m.appendChild(opt);
        }

        function renderOptionsMenu(m) {
            m.innerHTML = '';

            const tasksEnabled = db.settings.tabs.tasks;
            const dailiesEnabled = db.settings.tabs.dailies;
            const shopEnabled = db.settings.tabs.shopping;
            const notesEnabled = db.settings.tabs.notes;

            addGenericMenuOption(m, "Tasks", tasksEnabled, '#3b82f6', () => {
                // Prevent disabling all tabs
                if (tasksEnabled && !dailiesEnabled && !shopEnabled && !notesEnabled) {
                    showAlert("At least one tab must be enabled.");
                    return;
                }
                db.settings.tabs.tasks = !tasksEnabled;
                if (!db.settings.tabs.tasks && tab === 'tasks') switchTab(db.settings.tabOrder.find(t => db.settings.tabs[t]));
                db.settings.m = Date.now();
                updateTabVisibility();
                saveLocal(); pushToCloud();
                renderOptionsMenu(m); // In-place refresh
            });

            addGenericMenuOption(m, "Dailies", dailiesEnabled, '#10b981', () => {
                if (dailiesEnabled && !tasksEnabled && !shopEnabled && !notesEnabled) {
                    showAlert("At least one tab must be enabled.");
                    return;
                }
                db.settings.tabs.dailies = !dailiesEnabled;
                if (!db.settings.tabs.dailies && tab === 'dailies') switchTab(db.settings.tabOrder.find(t => db.settings.tabs[t]));
                db.settings.m = Date.now();
                updateTabVisibility();
                saveLocal(); pushToCloud();
                renderOptionsMenu(m); // In-place refresh
            });

            addGenericMenuOption(m, "Shopping", shopEnabled, '#f59e0b', () => {
                if (shopEnabled && !tasksEnabled && !dailiesEnabled && !notesEnabled) {
                    showAlert("At least one tab must be enabled.");
                    return;
                }
                db.settings.tabs.shopping = !shopEnabled;
                if (!db.settings.tabs.shopping && tab === 'shopping') switchTab(db.settings.tabOrder.find(t => db.settings.tabs[t]));
                db.settings.m = Date.now();
                updateTabVisibility();
                saveLocal(); pushToCloud();
                renderOptionsMenu(m); // In-place refresh
            });

            addGenericMenuOption(m, "Notes", notesEnabled, '#a1a1aa', () => {
                if (notesEnabled && !tasksEnabled && !dailiesEnabled && !shopEnabled) {
                    showAlert("At least one tab must be enabled.");
                    return;
                }
                db.settings.tabs.notes = !notesEnabled;
                if (!db.settings.tabs.notes && tab === 'notes') switchTab(db.settings.tabOrder.find(t => db.settings.tabs[t]));
                db.settings.m = Date.now();
                updateTabVisibility();
                saveLocal(); pushToCloud();
                renderOptionsMenu(m); // In-place refresh
            });

            const div = document.createElement('div'); div.className = 'menu-divider'; m.appendChild(div);

            // Help & Tutorial
            const hOpt = document.createElement('button');
            hOpt.className = 'menu-opt';
            hOpt.style.color = '#ffffff';
            hOpt.innerHTML = `<span>Help & Tutorial</span><span class="text-[10px] opacity-40 font-black">?</span>`;
            hOpt.onclick = (e) => { e.stopPropagation(); m.classList.remove('active'); openHelp(); };
            m.appendChild(hOpt);

            // Day Reset Time
            const rOpt = document.createElement('button');
            rOpt.className = 'menu-opt';
            rOpt.style.color = '#ffffff';
            const hr = db.settings.resetTime || 0;
            const displayHr = hr === 0 ? "12 AM" : (hr < 12 ? hr + " AM" : (hr === 12 ? "12 PM" : (hr - 12) + " PM"));
            rOpt.innerHTML = `<span>Day Reset Time</span><span class="text-[10px] font-black underline" style="color:#3b82f6">${displayHr}</span>`;
            rOpt.onclick = (e) => {
                e.stopPropagation();
                showPrompt("Reset Hour (0-23)", String(hr), (v) => {
                    const n = parseInt(v);
                    if (!isNaN(n) && n >= 0 && n <= 23) {
                        db.settings.resetTime = n;
                        db.settings.m = Date.now();
                        saveLocal(); pushToCloud(); renderOptionsMenu(m);
                    }
                });
            };
            m.appendChild(rOpt);

            // Sync ID Option
            const sOpt = document.createElement('button');
            sOpt.className = 'menu-opt';
            sOpt.style.color = '#ffffff';
            sOpt.innerHTML = `<span>Sync ID</span><span class="text-[10px] font-black underline" style="color:#3b82f6">${syncID || 'None'}</span>`;
            sOpt.onclick = (e) => { e.stopPropagation(); promptSyncID(); };
            m.appendChild(sOpt);

            // Sync History
            const history = getSyncHistory();
            if (history.length > 0) {
                const head = document.createElement('div');
                head.className = 'text-[9px] uppercase tracking-widest font-black text-zinc-600 px-3 mt-2 mb-1';
                head.innerText = 'Sync History';
                m.appendChild(head);
                history.forEach(id => {
                    if (id === syncID) return;
                    const hOpt = document.createElement('div');
                    hOpt.className = 'menu-opt flex items-center justify-between group';
                    hOpt.innerHTML = `
                        <div class="flex-1 cursor-pointer font-bold underline" style="color:#3b82f6" onclick="event.stopPropagation(); localStorage.setItem('todo_sync_id', '${id}'); window.location.reload();">
                            ${id}
                        </div>
                        <button class="p-2 text-zinc-700 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity" onclick="event.stopPropagation(); removeFromSyncHistory('${id}'); renderOptionsMenu(document.getElementById('fab-menu'));">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </button>
                    `;
                    m.appendChild(hOpt);
                });
            }
        }

        let menuCloseHandler = null;

        function toggleOptionsMenu(e) {
            e.stopPropagation();
            const m = document.getElementById('fab-menu'); // Reuse fab-menu style

            if (m.classList.contains('active')) {
                // Close it
                m.classList.remove('active');
                setTimeout(() => { if (!m.classList.contains('active')) m.style.display = 'none'; }, 200);
                if (menuCloseHandler) {
                    document.removeEventListener('click', menuCloseHandler);
                    menuCloseHandler = null;
                }
            } else {
                // Open it
                renderOptionsMenu(m);
                m.classList.add('active');

                // Click away to close
                if (menuCloseHandler) document.removeEventListener('click', menuCloseHandler);
                menuCloseHandler = (evt) => {
                    // Check if click is inside the menu OR on the toggle button
                    if (!m.contains(evt.target) && evt.target.id !== 'menu-btn' && !evt.target.closest('#menu-btn')) {
                        m.classList.remove('active');
                        document.removeEventListener('click', menuCloseHandler);
                        menuCloseHandler = null;
                    }
                };
                m.style.display = 'flex';
                setTimeout(() => m.classList.add('active'), 10);
                setTimeout(() => document.addEventListener('click', menuCloseHandler), 10);
            }
        }

        function openHelp() {
            const m = document.getElementById('help-modal');
            m.style.display = 'flex';
            setTimeout(() => {
                m.classList.add('active');
                m.querySelector('div').classList.remove('scale-95');
                m.querySelector('div').classList.add('scale-100');
            }, 10);
        }

        function openMobileNotes() {
            const m = document.getElementById('mobile-notes-modal');
            const textarea = m.querySelector('.notes-textarea');
            textarea.value = db.notes || '';
            m.style.display = 'flex';
            setTimeout(() => {
                m.classList.add('active');
                textarea.focus();
            }, 10);

            textarea.oninput = (e) => handleNoteInput(e.target.value);
        }

        function closeMobileNotes() {
            const m = document.getElementById('mobile-notes-modal');
            m.classList.remove('active');
            setTimeout(() => { if (!m.classList.contains('active')) m.style.display = 'none'; }, 300);
        }

        function closeHelp() {
            const m = document.getElementById('help-modal');
            m.querySelector('div').classList.remove('scale-100');
            m.querySelector('div').classList.add('scale-95');
            m.classList.remove('active');
            setTimeout(() => { if (!m.classList.contains('active')) m.style.display = 'none'; }, 300);
        }



        function updateTabVisibility() {
            const tabs = db.settings.tabs;
            document.getElementById('tab-tasks').style.display = tabs.tasks ? '' : 'none';
            document.getElementById('tab-dailies').style.display = tabs.dailies ? '' : 'none';
            document.getElementById('tab-shopping').style.display = tabs.shopping ? '' : 'none';
            document.getElementById('tab-notes').style.display = tabs.notes ? '' : 'none';

            document.getElementById('tasks-pane').style.display = tabs.tasks ? '' : 'none';
            document.getElementById('dailies-pane').style.display = tabs.dailies ? '' : 'none';
            document.getElementById('shopping-pane').style.display = tabs.shopping ? '' : 'none';
            document.getElementById('notes-pane').style.display = tabs.notes ? '' : 'none';

            // Desktop Sidebar
            const notesWrapper = document.querySelector('.notes-wrapper');
            if (notesWrapper) notesWrapper.style.display = tabs.notes ? '' : 'none';
        }
        function getSyncHistory() {
            try {
                return JSON.parse(localStorage.getItem('todo_sync_history') || '[]');
            } catch (e) { return []; }
        }
        function addToSyncHistory(id) {
            if (!id) return;
            id = id.toLowerCase().trim();
            const history = getSyncHistory();
            if (!history.includes(id)) {
                history.push(id);
                localStorage.setItem('todo_sync_history', JSON.stringify(history.slice(-5))); // Keep last 5
            }
        }
        function promptSyncID() {
            showPrompt("Sync ID", syncID || "", (id) => {
                if (id) {
                    id = id.toLowerCase().trim();
                    localStorage.setItem('todo_sync_id', id);
                    addToSyncHistory(id);
                    window.location.reload();
                }
            });
        }
        function removeFromSyncHistory(id) {
            const history = getSyncHistory().filter(x => x !== id);
            localStorage.setItem('todo_sync_history', JSON.stringify(history));
        }
        function saveLocal() { if (syncID) localStorage.setItem(`todo_db_${syncID}`, JSON.stringify(db)); }
        function loadLocal() {
            if (!syncID) return;
            const s = localStorage.getItem(`todo_db_${syncID}`);
            if (s) db = JSON.parse(s);
            else {
                // FALLBACK: If namespaced key is empty, check legacy key
                const legacy = localStorage.getItem('todo_db');
                if (legacy) {
                    db = JSON.parse(legacy);
                    // We don't delete legacy yet to be safe, but we'll save to namespaced from now on
                }
            }
        }

        function showPrompt(msg, val, cb) {
            document.getElementById('prompt-msg').innerText = msg;
            const input = document.getElementById('prompt-input');
            input.value = val || '';
            const btn = document.getElementById('prompt-confirm-btn');
            const submit = () => { cb(input.value); closePrompt(); };
            btn.onclick = submit;
            input.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); submit(); } };
            const m = document.getElementById('prompt-modal-overlay');
            m.style.display = 'flex';
            setTimeout(() => m.classList.add('active'), 10);
            setTimeout(() => input.focus(), 100);
        }

        function closePrompt() {
            const m = document.getElementById('prompt-modal-overlay');
            m.classList.remove('active');
            setTimeout(() => { if (!m.classList.contains('active')) m.style.display = 'none'; }, 200);
        }

        async function btnFAB(e) {
            if (e && e.stopPropagation) e.stopPropagation();
            const c = document.getElementById('fab-container');
            if (c.classList.contains('expanded')) {
                const i = document.getElementById('fab-input'), v = i.value.trim();
                if (v) {
                    const uid = Math.random(), m = Date.now(); animateUID = uid;
                    if (tab === 'shopping') {
                        db.shopping.push({ text: v, done: false, uid: uid, m: m, cat: activeShopCat || 'misc' });
                    } else if (tab === 'dailies') {
                        db.dailies.unshift({ text: v, done: false, uid: uid, m: m, section: activeDailySection, interval: 'daily' });
                    } else {
                        db.tasks.unshift({ text: v, done: false, uid: uid, m: m, section: activeTaskSection });
                    }
                    render(false); saveLocal(); pushToCloud(); i.value = '';
                }
                collapseInput();
            } else { expandInput(); }
        }

        // Section Edit Modal Logic
        let editingSectionId = null;
        let editingSectionColor = '#ffffff';

        function openSectionEdit(secId) {
            const list = tab === 'tasks' ? db.taskSections : (tab === 'dailies' ? db.dailySections : db.shopCategories);
            const sec = list.find(s => s.id === secId);
            if (!sec) return;

            editingSectionId = secId;
            editingSectionColor = sec.color || '#ffffff';

            const nameInput = document.getElementById('edit-sec-name');
            nameInput.value = sec.title;
            document.getElementById('edit-sec-color-input').value = editingSectionColor;

            // Highlight selected color
            document.querySelectorAll('.color-btn').forEach(b => {
                b.classList.toggle('selected', b.dataset.color === editingSectionColor);
            });

            const modal = document.getElementById('edit-sec-modal');
            modal.style.display = 'flex';
            setTimeout(() => modal.classList.add('active'), 10);

            const intervalCont = document.getElementById('edit-sec-interval-container');
            if (tab === 'dailies') {
                intervalCont.classList.remove('hidden');
                document.getElementById('edit-sec-interval').value = sec.interval || 'daily';
            } else {
                intervalCont.classList.add('hidden');
            }

            // Setup button handlers
            document.getElementById('save-sec-btn').onclick = saveSection;
            document.getElementById('cancel-sec-btn').onclick = closeEditModal;
            document.getElementById('delete-sec-btn').onclick = deleteSection;

            nameInput.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); saveSection(); } };

            document.querySelectorAll('.color-btn').forEach(b => {
                b.onclick = () => pickColor(b.dataset.color);
            });
            document.getElementById('edit-sec-color-input').onchange = (e) => pickColor(e.target.value);
        }

        function pickColor(color) {
            editingSectionColor = color;
            document.querySelectorAll('.color-btn').forEach(b => {
                b.classList.toggle('selected', b.dataset.color === color);
            });
            document.getElementById('edit-sec-color-input').value = color;
        }

        function saveSection() {
            const list = tab === 'tasks' ? db.taskSections : (tab === 'dailies' ? db.dailySections : db.shopCategories);
            const sec = list.find(s => s.id === editingSectionId);
            if (sec) {
                sec.title = document.getElementById('edit-sec-name').value.trim() || sec.title;
                sec.color = editingSectionColor;
                sec.m = Date.now();
                if (tab === 'dailies') {
                    sec.interval = document.getElementById('edit-sec-interval').value;
                }
                saveLocal(); pushToCloud(); render();
            }
            closeEditModal();
        }

        function deleteSection() {
            const list = tab === 'tasks' ? db.taskSections : (tab === 'dailies' ? db.dailySections : db.shopCategories);
            if (list.length <= 1) {
                alert("Can't delete the last section!");
                return;
            }

            // Check if section is empty
            const items = tab === 'tasks' ? db.tasks : (tab === 'dailies' ? db.dailies : db.shopping);
            const hasItems = items.some(i => (tab === 'tasks' ? i.section : (tab === 'dailies' ? i.section : i.cat)) === editingSectionId);

            const doDelete = () => {
                const defaultId = list[0].id;
                if (tab === 'tasks') {
                    db.tasks.forEach(t => { if (t.section === editingSectionId) { t.section = defaultId; t.m = Date.now(); } });
                    if (editingSectionId) db.deleted.push(editingSectionId);
                    db.taskSections = db.taskSections.filter(s => s.id !== editingSectionId);
                    if (activeTaskSection === editingSectionId) activeTaskSection = defaultId;
                } else if (tab === 'dailies') {
                    db.dailies.forEach(d => { if (d.section === editingSectionId) { d.section = defaultId; d.m = Date.now(); } });
                    if (editingSectionId) db.deleted.push(editingSectionId);
                    db.dailySections = db.dailySections.filter(s => s.id !== editingSectionId);
                    if (activeDailySection === editingSectionId) activeDailySection = defaultId;
                } else {
                    db.shopping.forEach(i => { if (i.cat === editingSectionId) { i.cat = defaultId; i.m = Date.now(); } });
                    if (editingSectionId) db.deleted.push(editingSectionId);
                    db.shopCategories = db.shopCategories.filter(c => c.id !== editingSectionId);
                    if (activeShopCat === editingSectionId) activeShopCat = defaultId;
                }
                saveLocal(); pushToCloud(); render();
                closeEditModal();
            };

            if (hasItems) {
                const type = (tab === 'tasks' || tab === 'dailies') ? 'section' : 'category';
                showConfirm(`Delete this ${type}? Items will move to the first one.`, doDelete);
            } else {
                doDelete();
            }
        }

        function closeEditModal() {
            const modal = document.getElementById('edit-sec-modal');
            modal.classList.remove('active');
            setTimeout(() => { if (!modal.classList.contains('active')) modal.style.display = 'none'; }, 200);
            editingSectionId = null;
        }

        // Section Reordering
        function initSectionSortable() {
            const isT = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
            const parent = tab === 'tasks' ? document.getElementById('list-content') : (tab === 'dailies' ? document.getElementById('dailies-content') : document.getElementById('shop-container'));
            if (!parent) return;

            const cols = parent.querySelectorAll('.main-col');
            const containers = cols.length > 0 ? Array.from(cols) : [parent];

            containers.forEach(el => {
                if (el._sortable) el._sortable.destroy();
                el._sortable = Sortable.create(el, {
                    group: 'sections-group',
                    animation: 200,
                    handle: '.section-header:not(.no-drag)',
                    draggable: '.section-block',
                    filter: '.trash-btn, .del, .chk-box',
                    preventOnFilter: true,
                    delay: isT ? 150 : 0,
                    delayOnTouchOnly: true,
                    forceFallback: true,
                    fallbackTolerance: 5,
                    ghostClass: 'sortable-ghost',
                    onStart: () => { window.isDraggingSectionGlobal = true; },
                    onEnd: () => {
                        window.isDraggingSectionGlobal = false;
                        // To get the new overall order, we need to look at both columns if they exist
                        const newOrder = [];
                        // We decide the order is Col1 then Col2. Or we could interleave. 
                        // Col1 then Col2 is predictable for the user.
                        const allCols = parent.querySelectorAll('.main-col');
                        if (allCols.length > 0) {
                            allCols.forEach((c, colIdx) => {
                                c.querySelectorAll('.section-block').forEach(el => {
                                    const secId = el.getAttribute('data-sec-id');
                                    const list = tab === 'tasks' ? db.taskSections : (tab === 'dailies' ? db.dailySections : db.shopCategories);
                                    const sec = list.find(s => s.id === secId);
                                    if (sec) {
                                        sec.col = colIdx;
                                        newOrder.push(sec);
                                    }
                                });
                            });
                        } else {
                            parent.querySelectorAll('.section-block').forEach(el => {
                                const secId = el.getAttribute('data-sec-id');
                                const list = tab === 'tasks' ? db.taskSections : (tab === 'dailies' ? db.dailySections : db.shopCategories);
                                const sec = list.find(s => s.id === secId);
                                if (sec) newOrder.push(sec);
                            });
                        }

                        if (tab === 'tasks') db.taskSections = newOrder;
                        else if (tab === 'dailies') db.dailySections = newOrder;
                        else db.shopCategories = newOrder;

                        // Important: Bump 'm' timestamp for ALL sections to ensure this new order wins via mergeDB logic
                        const now = Date.now();
                        newOrder.forEach(s => s.m = now);

                        db.settings.m = now;
                        saveLocal(); pushToCloud();
                        setTimeout(() => render(false), 50);
                    }
                });
            });
        }

        function toggleInput(cat, e) {
            e.stopPropagation();
            const c = document.getElementById('fab-container');
            const i = document.getElementById('fab-input');
            if (c.classList.contains('expanded') && activeCat === cat && !i.value.trim()) {
                collapseInput();
            } else {
                expandInput(cat);
            }
        }
        function expandInput() {
            document.getElementById('fab-container').classList.add('expanded');
            const inp = document.getElementById('fab-input');
            const list = tab === 'shopping' ? db.shopCategories : (tab === 'dailies' ? db.dailySections : db.taskSections);
            const activeId = tab === 'shopping' ? activeShopCat : (tab === 'dailies' ? activeDailySection : activeTaskSection);
            const sec = list.find(s => s.id === activeId);
            inp.placeholder = `Add to ${sec ? sec.title : (tab === 'shopping' ? 'Items' : tab)}...`;
            updateFabColor();
            setTimeout(() => { inp.focus(); inp.click(); }, 100);
        }

        function updateFabColor() {
            const icon = document.getElementById('fab-icon');
            if (!icon) return;
            let color = '#3b82f6'; // Default blue
            const list = tab === 'tasks' ? db.taskSections : (tab === 'dailies' ? db.dailySections : db.shopCategories);
            const activeId = tab === 'tasks' ? activeTaskSection : (tab === 'dailies' ? activeDailySection : activeShopCat);
            const sec = list.find(s => s.id === activeId);
            if (sec && sec.color) color = sec.color;
            icon.setAttribute('stroke', color);
        }
        function collapseInput() { document.getElementById('fab-container').classList.remove('expanded'); document.getElementById('fab-input').blur(); }
        function setupInputLogic() {
            window.onkeydown = (e) => {
                if (e.key === 'Escape') return collapseInput();
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true' || e.ctrlKey || e.metaKey) return;
                if (e.key === 'ArrowLeft') {
                    const enabledTabs = db.settings.tabOrder.filter(t => db.settings.tabs[t]);
                    const idx = enabledTabs.indexOf(tab);
                    const prev = enabledTabs[idx - 1];
                    if (prev) return switchTab(prev);
                }
                if (e.key === 'ArrowRight') {
                    const enabledTabs = db.settings.tabOrder.filter(t => db.settings.tabs[t]);
                    const idx = enabledTabs.indexOf(tab);
                    const next = enabledTabs[idx + 1];
                    if (next) return switchTab(next);
                }
                if (e.key.length === 1) { expandInput(); document.getElementById('fab-input').value = e.key; }
            };
            document.getElementById('fab-input').onkeypress = (e) => {
                if (e.key === 'Enter') {
                    const v = e.target.value.trim();
                    if (v) {
                        const uid = Math.random(), m = Date.now(); animateUID = uid;
                        if (tab === 'shopping') {
                            db.shopping.push({ text: v, done: false, uid: uid, m: m, cat: activeShopCat || 'misc' });
                        } else if (tab === 'dailies') {
                            db.dailies.unshift({ text: v, done: false, uid: uid, m: m, section: activeDailySection, interval: 'daily' });
                        } else {
                            db.tasks.unshift({ text: v, done: false, uid: uid, m: m, section: activeTaskSection });
                        }
                        render(false); saveLocal(); pushToCloud();
                        if (navigator.vibrate) navigator.vibrate(50);
                    }
                    e.target.value = ''; collapseInput();
                }
            };
            // Mobile Notes Input
            const mobNotes = document.getElementById('mobile-notes-textarea');
            if (mobNotes) {
                mobNotes.oninput = (e) => {
                    db.notes = e.target.value;
                    db.notesM = Date.now();
                    db.settings.m = Date.now();
                    saveLocal();
                    if (window.notesPushTimer) clearTimeout(window.notesPushTimer);
                    window.notesPushTimer = setTimeout(() => { pushToCloud(); }, 2000);
                };
            }
        }
        function handleBgClick(e) { if (e.target.id.includes('-pane')) collapseInput(); }

        function updateStatus(ok) {
            const s = document.getElementById('menu-btn');
            if (!s) return;
            s.className = (ok ? (pendingSync ? 'status-syncing' : 'status-online') : 'status-offline') + ' transition-all duration-300';
            s.title = ok ? (pendingSync ? 'Syncing...' : 'Online') : 'Offline';
        }
        init();
    </script>
</body>

</html>
